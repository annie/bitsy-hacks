<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>Write your game's title here</title>

<script type="text/bitsyGameData" id="exportedGameData">
Write your game's title here

# BITSY VERSION 8.0
# DEVELOPMENT BUILD -- BETA
! ROOM_FORMAT 0
! PAL_FORMAT 1

PAL 1
0052CC
809FFF
FFFFFF
NAME blueprint

ROOM 1
0000000000000000
0111111111111110
0100000000000010
0100000000000010
0100A00000000010
0100000000000010
0100000000000010
0100000000000010
0100000000000010
0100000000000010
0100000000000010
0100000000000010
0100000020000010
0100000000000010
0111111111111110
0000000000000000
NAME yard east
PAL 1

TIL 1
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME block

SPR 2
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME cat
DLG 1

ITM 3
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG 5

ITM 4
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME key
DLG 5

TIL 5
00000000
00000000
00111100
00100100
00100100
00111100
00000000
00000000
NAME path

EXT 6
00000000
00111100
01111110
01111110
01111110
01111010
01111110
01111110
NAME door
DLG 4
OUT 3 6 11
FX TNL
LOK 4

EXT 7
01111110
11111111
11111111
00000000
00001000
00000000
00000000
00000000
NAME step
OUT 2 8 7
FX FDB

END 8
01111000
01000110
01000001
01000110
01111000
01000000
01000000
11100000
>
01100000
01011000
01000110
01000001
01100110
01011000
01000000
11100000
NAME flag
DLG 5

AVA A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100

DLG 1
I'm a cat
NAME cat dialog

DLG 5
{RBW} The end! Thanks for playing! {/RBW}
NAME flag dialog

VAR A
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	bitsyCanvasAttach(document.getElementById("game"), width * scale);
	load_game(document.getElementById("exportedGameData").text.slice(1));
}
</script>

<script>
// todo : should these really be free floating globals?
var canvas;
var context;

var textureCache = {};
var nextTextureId = 0;

// todo : move max palette size into here?
var paletteMemory = [];

function bitsyCanvasAttach(canvasIn, renderSize) {
	canvas = canvasIn;
	canvas.width = renderSize;
	canvas.height = renderSize;
	context = canvas.getContext("2d");
}

function bitsyCanvasClear(colorIndex) {
	var color = paletteMemory[colorIndex];
	context.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
	context.fillRect(0, 0, canvas.width, canvas.height);
}

function bitsyCanvasPutTexture(textureId, x, y) {
	if (textureCache[textureId].canvas != null) {
		context.drawImage(
			textureCache[textureId].canvas,
			x,
			y,
			textureCache[textureId].img.width,
			textureCache[textureId].img.height);
	}
	else {
		context.putImageData(textureCache[textureId].img, x, y);
	}
}

function bitsyTextureCreate(width, height) {
	var textureId = nextTextureId;
	nextTextureId++;

	textureCache[textureId] = {
		img: context.createImageData(width, height),
		canvas: null,
	};

	return textureId;
}

// todo : revisit how I handle pixel scaling?
function bitsyTextureSetPixel(textureId, x, y, scale, colorIndex) {
	var img = textureCache[textureId].img;
	var color = (colorIndex >= 0 && colorIndex < paletteMemory.length) ? paletteMemory[colorIndex] : paletteMemory[0];

	if (!color) {
		color = [255, 0, 255, 255]; // error!
		// console.log("could not find color " + colorIndex);
		// console.log(paletteMemory);
	}

	for (var sy = 0; sy < scale; sy++) {
		for (var sx = 0; sx < scale; sx++) {
			var pxl = (((y * scale) + sy) * img.width * 4) + (((x * scale) + sx) * 4);

			img.data[pxl + 0] = color[0];
			img.data[pxl + 1] = color[1];
			img.data[pxl + 2] = color[2];
			img.data[pxl + 3] = color[3];
		}
	}
}

function bitsyTextureFill(textureId, colorIndex) {
	var img = textureCache[textureId].img;
	var color = (colorIndex >= 0 && colorIndex < paletteMemory.length) ? paletteMemory[colorIndex] : paletteMemory[0];

	for (var i = 0; i < img.data.length; i += 4) {
		img.data[i + 0] = color[0];
		img.data[i + 1] = color[1];
		img.data[i + 2] = color[2];
		img.data[i + 3] = color[3];
	}
}

// signal we're done drawing to this texture
function bitsyTextureCommit(textureId) {
	var img = textureCache[textureId].img;

	// convert to canvas: chrome has poor performance when working directly with image data
	var imageCanvas = document.createElement("canvas");
	imageCanvas.width = img.width;
	imageCanvas.height = img.height;
	var imageContext = imageCanvas.getContext("2d");
	imageContext.putImageData(img, 0, 0);

	textureCache[textureId].canvas = imageCanvas;
}

function bitsyTextureRelease(textureId) {
	delete textureCache[textureId];
}

// todo : return success or fail bool?
function bitsyPaletteRequestSize(size) {
	paletteMemory = [];

	for (var i = 0; i < size; i++) {
		paletteMemory.push([0, 0, 0, 255]);
	}

	// console.log(paletteMemory);
}

function bitsyPaletteSetColor(index, r, g, b, a) {
	paletteMemory[index] = [r, g, b, a];
}

function bitsyPaletteIsTransparent(index) {
	return index < paletteMemory.length ? paletteMemory[index][3] === 0 : false;
}
</script>

<script>
/* BITSY SPECS */
var width = 128;
var height = 128;

var tilesize = 8;
var roomsize = 16;
var mapsize = 8;

var scale = 4;
var text_scale = scale / 2;

var DEFAULT_REGISTRY_SIZE = 256;
var MAP_REGISTRY_SIZE = 5;

var PALETTE_SIZE = 16;
var ANIMATION_SIZE = 4;
var SCRIPT_SIZE = 1024;

var NULL_ID = "0"; // reserved for blank / default

var COLOR_INDEX = {
	TEXTBOX : 0,
	TEXT : 1,
	RAINBOW_START : 2,
	RAINBOW_END : 11,
	TRANSPARENT : 12,
	BACKGROUND : 13,
	TILE : 14,
	SPRITE : 15,
};

var WRITABLE_COLOR_START = COLOR_INDEX.BACKGROUND;
var ENABLE_COLOR_OVERRIDE = false;
</script>

<script>
/* KEYWORDS */
var TYPE_KEY = {
	PALETTE : "PAL",
	ROOM : "ROOM",
	MAP : "MAP",
	AVATAR : "AVA",
	TILE : "TIL",
	SPRITE : "SPR",
	ITEM : "ITM",
	EXIT : "EXT",
	ENDING : "END",
	DIALOG : "DLG",
	SCRIPT : "CUE",
	DEFAULT_FONT : "DEFAULT_FONT",
	TEXT_DIRECTION : "TEXT_DIRECTION",
	FONT : "FONT",
};

var ARG_KEY = {
	NAME : "NAME",
	IS_WALL : "WAL",
	TRANSITION_EFFECT : "FX",
	TRANSITION_EFFECT_UP : "FXU",
	TRANSITION_EFFECT_DOWN : "FXD",
	TRANSITION_EFFECT_LEFT : "FXL",
	TRANSITION_EFFECT_RIGHT : "FXR",
	COLOR : "COL",
	BACKGROUND : "BGC",
	DIALOG_SCRIPT : TYPE_KEY.DIALOG,
	FRAME_TICK_SCRIPT : "TIK",
	KNOCK_INTO_SCRIPT : "NOK",
	BUTTON_DOWN_SCRIPT : "BTN",
	EXIT_DESTINATION : "OUT",
	LOCK : "LOK",
};

var BUTTON_KEY = {
	UP : "UP",
	DOWN : "DWN",
	LEFT : "LFT",
	RIGHT : "RGT",
	OKAY : "OK",
	// TODO: any others? or is this it?
	
	// stub for possible future cancel button -
	// I don't think I need it yet and it complicates touch controls,
	// but I might want it eventually
	// CANCEL : "X",
};

/* SCRIPT SYMBOLS */
var CURLICUE_KEY = {
	OPEN : "{",
	CLOSE : "}",
	DIALOG : ">>",
	SEQUENCE : "SEQ",
	CYCLE : "CYC",
	SHUFFLE : "SHF",
	CHOICE : "PIK",
	CONDITIONAL : "IF",
	FUNCTION : "FN",
	VARIABLE : "VAR",
	ASSIGN : "SET",
	TABLE : "TBL",
	ENTRY : ":",
};

var BOOL_KEY = {
	YES : "YES", // => TRUE
	NO : "NO", // => FALSE, NULL, NIL
};

// some standard variable / entry names
var ENTRY_KEY = {
	THIS_SPRITE : "THIS",
	THAT_SPRITE : "THAT", // sprite you knocked into -- you should this be stored here?
	SPRITE_TYPE : "TYPE",
	SPRITE_ID : "ID",
	SPRITE_NAME : ARG_KEY.NAME,
	SPRITE_X : "X",
	SPRITE_Y : "Y",
	SPRITE_TILE_ID : TYPE_KEY.TILE,
	SPRITE_BACKGROUND : ARG_KEY.BACKGROUND,
	SPRITE_COLOR : ARG_KEY.COLOR,
	SPRITE_WALL : ARG_KEY.IS_WALL,
	SPRITE_LOCKED : ARG_KEY.LOCK,
};

var DEBUG_KEY = {
	ERROR : "ERR",
};

var TRANSITION_KEY = {
	FADE_WHITE : "FDW",
	FADE_BLACK : "FDB",
	WAVE : "WVE",
	TUNNEL : "TNL",
	SLIDE_UP : "SLU",
	SLIDE_DOWN : "SLD",
	SLIDE_LEFT : "SLL",
	SLIDE_RIGHT : "SLR",
};

var FONT_KEY = {
	SIZE : "SIZE",
	CHARACTER_START : "CHAR",
	CHARACTER_SIZE : "CHAR_SIZE",
	CHARACTER_OFFSET : "CHAR_OFFSET",
	CHARACTER_SPACING : "CHAR_SPACING",
};

var TEXT_DIRECTION_KEY = {
	LEFT_TO_RIGHT : "LTR",
	RIGHT_TO_LEFT : "RTL",
};

var MISC_KEY = {
	COMMENT : "#",
	FLAG : "!",
	NEXT : ">",
};

// for back compat with old versions
var LEGACY_KEY = {
	ROOM : "SET",
	POSITION : "POS",
	SEPARATOR : ",",
};

var SECRET_KEY = {
	INFINITE_MEMORY : "INFINITE_MEM",
	SUPER_PALETTE : "SUPER_PAL",
	SUPER_ANIMATION : "SUPER_ANM",
	SUPER_COLOR : "SUPER_COL",
	SECRET_COLOR : "SECRET_COL",
	SUPER_SCRIPT : "SUPER_SCRIPT",
};
</script>

<script>
/* BASE 256 IDs */

// unicode character mapping (modified version of code page 437)
var ID_CHAR_MAPPING = [
	// numbers:
	0x0030, // zero (empty)
	0x0031, // one (filled)
	0x0032,
	0x0033,
	0x0034,
	0x0035,
	0x0036,
	0x0037,
	0x0038,
	0x0039,
	// lowercase letters:
	0x0061,
	0x0062,
	0x0063,
	0x0064,
	0x0065,
	0x0066,
	0x0067,
	0x0068,
	0x0069,
	0x006A,
	0x006B,
	0x006C,
	0x006D,
	0x006E,
	0x006F,
	0x0070,
	0x0071,
	0x0072,
	0x0073,
	0x0074,
	0x0075,
	0x0076,
	0x0077,
	0x0078,
	0x0079,
	0x007A,
	// uppercase letters:
	0x0041,
	0x0042,
	0x0043,
	0x0044,
	0x0045,
	0x0046,
	0x0047,
	0x0048,
	0x0049,
	0x004A,
	0x004B,
	0x004C,
	0x004D,
	0x004E,
	0x004F,
	0x0050,
	0x0051,
	0x0052,
	0x0053,
	0x0054,
	0x0055,
	0x0056,
	0x0057,
	0x0058,
	0x0059,
	0x005A,
	// other symbols from page 437:
	0x263A, // row 0
	0x263B,
	0x2665,
	0x2666,
	0x2663,
	0x2660,
	0x2022,
	0x25D8,
	0x25CB,
	0x25D9,
	0x2642,
	0x2640,
	0x266A,
	0x266B,
	0x263C,
	0x25BA, // row 1
	0x25C4,
	0x2195,
	0x203C,
	0x00B6,
	0x00A7,
	0x25AC,
	0x21A8,
	0x2191,
	0x2193,
	0x2192,
	0x2190,
	0x221F,
	0x2194,
	0x25B2,
	0x25BC,
	0x0021, // row 2
	0x0022,
	0x0023,
	0x0024,
	0x0025,
	0x0026,
	0x0027,
	0x0028,
	0x0029,
	0x002A,
	0x002B,
	0x002C,
	0x002D,
	0x002E,
	0x002F,
	0x003A, // row 3
	0x003B,
	0x003C,
	0x003D,
	0x003E,
	0x003F,
	0x0040, // row 4
	0x005B, // row 5
	0x005C,
	0x005D,
	0x005E,
	0x005F,
	0x0060, // row 6
	0x007B, // row 7
	0x007C,
	0x007D,
	0x007E,
	0x2302,
	0x00C7, // row 8
	0x00FC,
	0x00E9,
	0x00E2,
	0x00E4,
	0x00E0,
	0x00E5,
	0x00E7,
	0x00EA,
	0x00EB,
	0x00E8,
	0x00EF,
	0x00EE,
	0x00EC,
	0x00C4,
	0x00C5,
	0x00C9, // row 9
	0x00E6,
	0x00C6,
	0x00F4,
	0x00F6,
	0x00F2,
	0x00FB,
	0x00F9,
	0x00FF,
	0x00D6,
	0x00DC,
	0x00A2,
	0x00A3,
	0x00A5,
	0x20A7,
	0x0192,
	0x00E1, // row A
	0x00ED,
	0x00F3,
	0x00FA,
	0x00F1,
	0x00D1,
	0x00AA,
	0x00BA,
	0x00BF,
	0x2310,
	0x00AC,
	0x00BD,
	0x00BC,
	0x00A1,
	0x00AB,
	0x00BB,
	0x2591, // row B
	0x2592,
	0x2593,
	0x2502,
	0x2524,
	0x2561,
	0x2562,
	0x2556,
	0x2555,
	0x2563,
	0x2551,
	0x2557,
	0x255D,
	0x255C,
	0x255B,
	0x2510,
	0x2514, // row C
	0x2534,
	0x252C,
	0x251C,
	0x2500,
	0x253C,
	0x255E,
	0x255F,
	0x255A,
	0x2554,
	0x2569,
	0x2566,
	0x2560,
	0x2550,
	0x256C,
	0x2567,
	0x2568, // row D
	0x2564,
	0x2565,
	0x2559,
	0x2558,
	0x2552,
	0x2553,
	0x256B,
	0x256A,
	0x2518,
	0x250C,
	0x2588,
	0x2584,
	0x258C,
	0x2590,
	0x2580,
	0x03B1, // row E
	0x00DF,
	0x0393,
	0x03C0,
	0x03A3,
	0x03C3,
	0x00B5,
	0x03C4,
	0x03A6,
	0x0398,
	0x03A9,
	0x03B4,
	0x221E,
	0x03C6,
	0x03B5,
	0x2229,
	0x2261, // row F
	0x00B1,
	0x2265,
	0x2264,
	0x2320,
	0x2321,
	0x00F7,
	0x2248,
	0x00B0,
	0x2219,
	0x00B7,
	0x221A,
	0x207F,
	0x00B2,
	0x25A0,
	// misc extra:
	0x0259, // schwa
	0x2020, // dagger
	0x00D8, // O with slash
];

var ID_MAPPING_REVERSE = {};

// todo : init in function?
for (var i = 0; i < ID_CHAR_MAPPING.length; i++) {
	ID_MAPPING_REVERSE[String.fromCharCode(ID_CHAR_MAPPING[i])] = i;
}

function debugPrintIdMapping() {
	for (var i = 0; i < ID_CHAR_MAPPING.length; i++) {
		var priorIndex = ID_CHAR_MAPPING.indexOf(ID_CHAR_MAPPING[i]);

		console.log(
			(i).toString().padStart(3, "0") + " :: " + 
			toB256(i) + " :: " + 
			ID_CHAR_MAPPING[i].toString(16).toUpperCase().padStart(4, "0") +
			(priorIndex != i ? " !! " + priorIndex + " !!" : ""));
	}
}

function debugPrintIdGrid() {
	var grid = "";
	for (var i = 0; i < roomsize; i++) {
		var row = "";
		for (var j = 0; j < roomsize; j++) {
			row += toB256((i*roomsize)+j);
		}
		row += "\n";
		grid += row;
	}
	console.log(grid);
}

function toB256(num) {
	var str = "";
	var place = 0;
	var i = (num >> (8 * place)) & 255;

	str += String.fromCharCode(ID_CHAR_MAPPING[i]);
	num -= (i << (8 * place));

	while (num > 0) {
		place++;
		i = (num >> (8 * place)) & 255;
		str = String.fromCharCode(ID_CHAR_MAPPING[i]) + str;
		num -= (i << (8 * place));
	}

	return str;
}

function fromB256(str) {
	var num = 0;

	for (var i = str.length - 1; i >= 0; i--) {
		var place = (str.length - 1) - i;
		num += ID_MAPPING_REVERSE[str[i]] * Math.pow(256, place);
	}

	return num;
}

function nextB256Id(objectRegistry, min, max) {
	var id = null;
	var index = min;

	while (id === null && (max === null || index < max)) {
		var str = toB256(index);
		if (!(str in objectRegistry)) {
			id = str;
		}

		index++;
	}

	return id;
}

function sortedIdList(objectRegistry) {
	var ids = [];

	for (var id in objectRegistry) {
		ids.push(id);
	}

	var sorted = ids.sort(function(a, b) { return fromB256(a) - fromB256(b); });

	return sorted;
}
</script>

<script>
/* TODO
	- decrease some of the global-ness?
		- for example: pass in a game data holder?
*/

function Parser() {

this.ParseWorld = parseWorld;

this.SerializeWorld = serializeWorld;

function parseWorld(file) {
	resetFlags();

	var versionNumber = 0;

	// flags to keep track of which compatibility conversions
	// need to be applied to this game data
	var compatibilityFlags = {
		convertSayToPrint : false,
		combineEndingsWithDialog : false,
		convertImplicitSpriteDialogIds : false,
	};

	var tileTypes = [
		TYPE_KEY.AVATAR,
		TYPE_KEY.TILE,
		TYPE_KEY.SPRITE,
		TYPE_KEY.ITEM,
		TYPE_KEY.EXIT,
		TYPE_KEY.ENDING,
	];

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === MISC_KEY.COMMENT) {
			// collect version number (from a comment.. hacky I know)
			var bitsyVersionComment = MISC_KEY.COMMENT + " BITSY VERSION ";
			if (curLine.indexOf(bitsyVersionComment) != -1) {
				versionNumber = parseFloat(curLine.replace(bitsyVersionComment, ""));

				if (versionNumber < 5.0) {
					compatibilityFlags.convertSayToPrint = true;
				}

				if (versionNumber < 7.0) {
					compatibilityFlags.combineEndingsWithDialog = true;
					compatibilityFlags.convertImplicitSpriteDialogIds = true;
				}
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == TYPE_KEY.PALETTE) {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === TYPE_KEY.ROOM || getType(curLine) === LEGACY_KEY.ROOM) {
			i = parseRoom(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === TYPE_KEY.MAP) {
			i = parseMap(lines, i);
		}
		// TODO : do I need to do anything about detecting END-as-dialog vs END-as-object???
		else if (tileTypes.indexOf(getType(curLine)) != -1) {
			i = parseTile(lines, i, getType(curLine));
		}
		else if (getType(curLine) === TYPE_KEY.DIALOG) {
			i = parseDialog(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === TYPE_KEY.ENDING && compatibilityFlags.combineEndingsWithDialog) {
			// parse endings for back compat
			i = parseEnding(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === TYPE_KEY.SCRIPT) {
			i = parseFunctionScript(lines, i);
		}
		else if (getType(curLine) === CURLICUE_KEY.VARIABLE) {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === TYPE_KEY.DEFAULT_FONT) {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === TYPE_KEY.TEXT_DIRECTION) {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === TYPE_KEY.FONT) {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === MISC_KEY.FLAG) {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	// scriptCompatibility(compatibilityFlags);

	curRoom = sortedIdList(room)[0];

	return versionNumber;
}

// TODO : rewrite
function scriptCompatibility(compatibilityFlags) {
	// if (compatibilityFlags.convertSayToPrint) {
	// 	console.log("CONVERT SAY TO PRINT!");

	// 	var PrintFunctionVisitor = function() {
	// 		var didChange = false;
	// 		this.DidChange = function() { return didChange; };

	// 		this.Visit = function(node) {
	// 			if (node.type != "function") {
	// 				return;
	// 			}

	// 			if (node.name === "say") {
	// 				node.name = "print";
	// 				didChange = true;
	// 			}
	// 		};
	// 	};

	// 	for (dlgId in dialog) {
	// 		var dialogScript = scriptInterpreter.Parse(dialog[dlgId].src);
	// 		var visitor = new PrintFunctionVisitor();
	// 		dialogScript.VisitAll(visitor);
	// 		if (visitor.DidChange()) {
	// 			var newDialog = dialogScript.Serialize();
	// 			if (newDialog.indexOf("\n") > -1) {
	// 				newDialog = '"""\n' + newDialog + '\n"""';
	// 			}
	// 			dialog[dlgId].src = newDialog;
	// 		}
	// 	}
	// }
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line, arg) {
	return line.split(" ")[arg];
}

function tryGetArg(line, arg) {
	var lineArgs = line.split(" ");

	if (lineArgs.length > arg) {
		return lineArgs[arg];
	}
	else {
		return null;
	}
}

function getCoord(line, arg) {
	return getArg(line, arg).split(LEGACY_KEY.SEPARATOR);
}

function parseTitle(lines, i) {
	return parseScript(lines, i, { id: titleId, });
}

function parsePalette(lines, i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;

	var colors = [];
	var name = null;

	var maxWritablePaletteSize = (PALETTE_SIZE ? (PALETTE_SIZE - WRITABLE_COLOR_START) : PALETTE_SIZE);

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");

		if (args[0] === ARG_KEY.NAME) {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else if (flags.PAL_FORMAT === 0) {
			var col = [];

			lines[i].split(LEGACY_KEY.SEPARATOR).forEach(function(i) {
				col.push(parseInt(i));
			});

			if (maxWritablePaletteSize === null || colors.length < maxWritablePaletteSize) {
				colors.push(col);
			}
		}
		else if (flags.PAL_FORMAT === 1) {
			if (maxWritablePaletteSize === null || colors.length < maxWritablePaletteSize) {
				colors.push(fromHex(lines[i]));
			}
		}

		i++;
	}

	palette[id] = createPalette(id, name, colors);

	return i;
}

function parseRoom(lines, i, compatibilityFlags) {
	var id = getId(lines[i]);
	room[id] = createRoom(id);
	i++;

	// create tile map
	if (flags.ROOM_FORMAT == 0) {
		// single char tile ids, no commas
		var end = i + roomsize;
		var y = 0;
		for (; i < end; i++) {
			for (x = 0; x < roomsize; x++) {
				room[id].tilemap[y][x] = lines[i].charAt(x);
			}

			y++;
		}
	}
	else if (flags.ROOM_FORMAT == 1) {
		// multiple char tile ids, comma separated
		var end = i + roomsize;
		var y = 0;
		for (; i < end; i++) {
			var lineSep = lines[i].split(LEGACY_KEY.SEPARATOR);
			for (x = 0; x < roomsize; x++) {
				room[id].tilemap[y][x] = lineSep[x];
			}

			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		/* NAME */
		if (getType(lines[i]) === ARG_KEY.NAME) {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
		}
		/* PALETTE */
		else if (getType(lines[i]) === TYPE_KEY.PALETTE) {
			room[id].pal = getId(lines[i]);
		}
		/* ADDITIONAL TILES & SPRITES */
		else if (getType(lines[i]) === TYPE_KEY.TILE) {
			// todo : does this work the way I want?
			var tileId = getId(lines[i]);
			var tileX = parseInt(getArg(lines[i], 2));
			var tileY = parseInt(getArg(lines[i], 3));
			room[id].tileOverlay.push(createSpriteLocation(tileId, tileX, tileY));
		}
		// LEGACY SPRITE AND ITEM // TODO : only allow for old files?
		else if (getType(lines[i]) === TYPE_KEY.SPRITE || getType(lines[i]) === TYPE_KEY.ITEM) {
			var sprId = getId(lines[i]);
			var sprCoord = lines[i].split(" ")[2].split(LEGACY_KEY.SEPARATOR);
			var sprLocation = createSpriteLocation(sprId, parseInt(sprCoord[0]), parseInt(sprCoord[1]));
			room[id].tileOverlay.push(sprLocation);

			// TODO : do I need to support reading in the old "find and replace" sprite format for back compat?
		}
		// LEGACY WALLS
		else if (getType(lines[i]) === ARG_KEY.IS_WALL) {
			/* DEFINE COLLISIONS (WALLS) */
			// TODO : remove this deprecated feature at some point
			room[id].walls = getId(lines[i]).split(LEGACY_KEY.SEPARATOR);
		}
		// LEGACY EXITS
		else if (getType(lines[i]) === TYPE_KEY.EXIT) {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2
			var exitCoords = exitArgs[1].split(LEGACY_KEY.SEPARATOR);
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(LEGACY_KEY.SEPARATOR);
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				dlg: null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == ARG_KEY.TRANSITION_EFFECT) {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == TYPE_KEY.DIALOG) {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			// TODO : back compat
		}
		// LEGACY ENDINGS
		else if (getType(lines[i]) === TYPE_KEY.ENDING) {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			// compatibility with when endings were stored separate from other dialog
			if (compatibilityFlags.combineEndingsWithDialog) {
				endId = "end_" + endId;
			}

			var endCoords = getCoord(lines[i], 2);
			var end = {
				id : endId,
				x : parseInt(endCoords[0]),
				y : parseInt(endCoords[1]),
			};

			// TODO : back compat
		}

		i++;
	}

	return i;
}

function parseMap(lines, i) {
	var id = getId(lines[i]);
	map[id] = createMap(id);
	i++;

	var end = i + mapsize;
	var y = 0;

	for (; i < end; i++) {
		for (x = 0; x < mapsize; x++) {
			var roomId = lines[i][x];
			map[id].map[y][x] = roomId;

			// NOTE: assumes rooms already exist!
			if (roomId != NULL_ID) {
				room[roomId].mapLocation.id = id;
				room[roomId].mapLocation.x = x;
				room[roomId].mapLocation.y = y;
			}
		}

		y++;
	}

	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === ARG_KEY.TRANSITION_EFFECT_UP) {
			map[id].transition_effect_up = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.TRANSITION_EFFECT_DOWN) {
			map[id].transition_effect_down = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.TRANSITION_EFFECT_LEFT) {
			map[id].transition_effect_left = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.TRANSITION_EFFECT_RIGHT) {
			map[id].transition_effect_right = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.NAME) {
			var name = lines[i].split(/\s(.+)/)[1]; // todo : make helper function?
			map[id].name = name;
			// TODO : add to global name registry?
		}

		i++;
	}

	return i;
}

function isColorIndexInValidRange(index) {
	return (index >= WRITABLE_COLOR_START) && (PALETTE_SIZE === null || index < PALETTE_SIZE);
}

function parseTile(lines, i, type) {
	var id = getId(lines[i]);
	i++;

	var options = {};

	// parse drawing
	var drawingResult = parseDrawing(lines, i);
	i = drawingResult.i;
	options.drawingData = drawingResult.drawingData;

	// todo : how do we handle back compat for SPR A?
	var isPlayer = (type === TYPE_KEY.AVATAR) && playerId === null;

	if (isPlayer) {
		playerId = id;
		type = TYPE_KEY.AVATAR;
		options.inventory = {};
	}

	// turn extra avatars into sprites
	if (!isPlayer && (type === TYPE_KEY.AVATAR)) {
		type === TYPE_KEY.SPRITE;
	}

	// background tiles are restricted from several properties
	var isNotBackgroundTile = (type != TYPE_KEY.TILE);

	// read all other properties
	while (i < lines.length && lines[i].length > 0) { // stop at empty line
		if (getType(lines[i]) === ARG_KEY.NAME) {
			/* NAME */
			options.name = lines[i].split(/\s(.+)/)[1];
		}
		else if (getType(lines[i]) === ARG_KEY.COLOR) {
			if (ENABLE_COLOR_OVERRIDE) {
				/* COLOR OFFSET INDEX */
				var colorIndexOffset = parseInt(getId(lines[i]));
				var colorIndex = COLOR_INDEX.BACKGROUND + colorIndexOffset;
				if (isColorIndexInValidRange(colorIndex)) {
					options.col = colorIndexOffset;
				}
			}
		}
		else if (getType(lines[i]) === ARG_KEY.BACKGROUND) {
			if (ENABLE_COLOR_OVERRIDE) {
				/* BACKGROUND COLOR OFFSET INDEX */
				var colorIndexOffset = parseInt(getId(lines[i]));
				var colorIndex = COLOR_INDEX.BACKGROUND + colorIndexOffset;
				if (isColorIndexInValidRange(colorIndex)) {
					options.bgc = colorIndexOffset;
				}
			}
		}
		else if (getType(lines[i]) === ARG_KEY.IS_WALL && type === TYPE_KEY.TILE) {
			// only tiles set their initial collision mode
			var wallArg = getArg(lines[i], 1);
			if (wallArg === BOOL_KEY.YES) {
				options.isWall = true;
			}
			else if (wallArg === BOOL_KEY.NO) {
				options.isWall = false;
			}
		}
		else if (getType(lines[i]) === ARG_KEY.DIALOG_SCRIPT && isNotBackgroundTile) {
			options.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.FRAME_TICK_SCRIPT && isNotBackgroundTile) {
			options.tickDlgId = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.KNOCK_INTO_SCRIPT && isNotBackgroundTile) {
			options.knockDlgId = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.BUTTON_DOWN_SCRIPT && isNotBackgroundTile) {
			options.buttonDownDlgId = getId(lines[i]);
		}
		else if (getType(lines[i]) === LEGACY_KEY.POSITION && type === TYPE_KEY.SPRITE) {
			/* STARTING POSITION */
			// NOTE: I still need this to read in old unique position data from sprites
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(LEGACY_KEY.SEPARATOR);

			// NOTE: assumes rooms have all been created!
			room[roomId].tileOverlay.push(
				createSpriteLocation(
					id,
					parseInt(coordArgs[0]),
					parseInt(coordArgs[1])));
		}
		else if (getType(lines[i]) === TYPE_KEY.ITEM && isPlayer) {
			/* ITEM STARTING INVENTORY */
			// TODO: This is only used by the player avatar -- should I move it out of sprite data?
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			options.inventory[itemId] = itemCount;
		}
		else if (getType(lines[i]) === ARG_KEY.EXIT_DESTINATION && type === TYPE_KEY.EXIT) {
			// TODO : maintain the same format as before with the comma seperation?
			options.destRoom = getId(lines[i]);
			options.destX = parseInt(getArg(lines[i], 2));
			options.destY = parseInt(getArg(lines[i], 3));
		}
		else if (getType(lines[i]) === ARG_KEY.TRANSITION_EFFECT && type === TYPE_KEY.EXIT) {
			options.transition_effect = getId(lines[i]);
		}
		else if (getType(lines[i]) === ARG_KEY.LOCK && (type === TYPE_KEY.EXIT || type === TYPE_KEY.ENDING)) {
			options.lockItem = getId(lines[i]);
		}

		i++;
	}

	createTile(id, type, options);

	return i;
}

function parseDrawing(lines, i) {
	var frameList = []; // init list of frames
	var curFrame = createGrid(tilesize, 0); // init first frame

	var y = 0;

	// use first row to detect input tile size (must be square)
	var inputTileSize = lines[i].length;
	// console.log(inputTileSize);

	while (y < inputTileSize) {
		var l = lines[i + y];

		for (x = 0; x < inputTileSize; x++) {
			if (x < tilesize && y < tilesize) {
				curFrame[y][x] = parseInt(l.charAt(x));
			}
		}

		y++;

		if (y === inputTileSize) {
			if (ANIMATION_SIZE === null || frameList.length < ANIMATION_SIZE) {
				frameList.push(curFrame);
			}

			i = i + y;

			if (lines[i] != undefined && lines[i].charAt(0) === MISC_KEY.NEXT) {
				// start next frame!
				curFrame = createGrid(tilesize, 0);

				//start the count over again for the next frame
				i++;

				y = 0;
			}
		}
	}

	return { i: i, drawingData: frameList };
}

function parseScript(lines, i, options) {
	var backCompatPrefix = options && options.backCompatPrefix ? options.backCompatPrefix : "";
	var convertImplicitSpriteDialogIds = options && options.convertImplicitSpriteDialogIds;

	var id = null;

	if (options && options.id) {
		id = options.id;
	}
	else {
		id = getId(lines[i]);
		i++;
	}

	var type = ScriptType.Dialog;
	if (options && options.type) {
		type = options.type;
	}

	id = backCompatPrefix + id;

	var dialogStart = CURLICUE_KEY.OPEN + CURLICUE_KEY.DIALOG;
	var functionStart = CURLICUE_KEY.OPEN + CURLICUE_KEY.FUNCTION;

	var script = "";

	var startsWithDialogExpression = (type === ScriptType.Dialog)
		&& (lines[i].length >= 3) && (lines[i].indexOf(dialogStart) === 0);

	var startsWithFunctionDefinition = (type === ScriptType.Function)
		&& (lines[i].length >= 3) && (lines[i].indexOf(functionStart) === 0);

	if (startsWithDialogExpression || startsWithFunctionDefinition) {
		// multi-line script
		// TODO : handle strings inside quotes
		script += lines[i][0];
		var bracesCount = 1;
		var charIndex = 1;

		while (bracesCount > 0) {
			if (charIndex >= lines[i].length) {
				script += "\n";
				i++;
				charIndex = 0;
			}
			else {
				script += lines[i][charIndex];

				if (lines[i][charIndex] === CURLICUE_KEY.OPEN) {
					bracesCount++;
				}
				else if (lines[i][charIndex] === CURLICUE_KEY.CLOSE) {
					bracesCount--;
				}

				charIndex++;
			}
		}
	}
	else if (type === ScriptType.Dialog) {
		// single line dialog script
		script += lines[i];
	}
	else {
		// oh no!
	}

	i++;

	dialog[id] = createScript(id, null, script, type);

	if (convertImplicitSpriteDialogIds) {
		// explicitly hook up dialog that used to be implicitly
		// connected by sharing sprite and dialog IDs in old versions
		if (tile[id] && tile[id].type === TYPE_KEY.SPRITE) {
			if (tile[id].dlg === undefined || tile[id].dlg === null) {
				tile[id].dlg = id;
			}
		}
	}

	return i;
}

function parseDialog(lines, i, compatibilityFlags) {
	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	var options = { convertImplicitSpriteDialogIds: compatibilityFlags.convertImplicitSpriteDialogIds, };
	i = parseScript(lines, i, options);

	if (lines[i].length > 0 && getType(lines[i]) === ARG_KEY.NAME) {
		dialog[id].name = lines[i].split(/\s(.+)/)[1]; // TODO : hacky to keep copying this regex around...
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(lines, i, compatibilityFlags) {
	var options = {
		backCompatPrefix: "end_",
		convertImplicitSpriteDialogIds: compatibilityFlags.convertImplicitSpriteDialogIds,
	};

	// todo : need to read in names for back compat?

	return parseScript(lines, i, options);
}

function parseFunctionScript(lines, i) {
	return parseScript(lines, i, { type: ScriptType.Function, });
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = scriptInterpreter.ParseValue(lines[i]);
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

// TODO : WIP
// function parseTextScale(lines, i) {
// 	var scaleFlag = getArg(lines[i], 1);

// 	if (scaleFlag === "1") {
// 		// 1x scale
// 		text_scale = scale;
// 	}
// 	else if (scaleFlag === "2") {
// 		// 2x scale
// 		text_scale = scale / 2; // NOTE: assumes scale is an even number
// 	}

// 	i++;
// 	return i;
// }

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource(localFontFilename, localFontData);

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt(valStr);

	// handle secret flags
	if (id === SECRET_KEY.INFINITE_MEMORY && flags[id] != 0) {
		DEFAULT_REGISTRY_SIZE = null;
		MAP_REGISTRY_SIZE = null;
	}

	if (id === SECRET_KEY.SUPER_PALETTE && flags[id] != 0) {
		PALETTE_SIZE = null;
	}

	if (id === SECRET_KEY.SUPER_ANIMATION && flags[id] != 0) {
		ANIMATION_SIZE = null;
	}

	if (id === SECRET_KEY.SUPER_COLOR && flags[id] != 0) {
		ENABLE_COLOR_OVERRIDE = true;
	}

	if (id === SECRET_KEY.SECRET_COLOR && flags[id] != 0) {
		WRITABLE_COLOR_START = COLOR_INDEX.TEXTBOX;
	}

	if (id === SECRET_KEY.SUPER_SCRIPT && flags[id] != 0) {
		SCRIPT_SIZE = null;
	}

	i++;

	return i;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null) {
		skipFonts = false;
	}

	flags.PAL_FORMAT = 1; // new default format (hex)

	var worldStr = "";

	/* TITLE */
	var titleStr = getTitle();
	var titleScriptRoot = scriptInterpreter.Parse(titleStr, DialogWrapMode.No);
	var titleFlat = scriptInterpreter.SerializeFlat(titleScriptRoot);
	var titleCharCount = titleFlat.length;

	if (SCRIPT_SIZE === null || titleCharCount <= SCRIPT_SIZE) {
		worldStr += titleStr + "\n";
	}
	else {
		worldStr += "\n";
	}

	worldStr += "\n";

	/* VERSION */
	worldStr += MISC_KEY.COMMENT + " BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += MISC_KEY.COMMENT + " DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";

	/* FLAGS */
	for (f in flags) {
		worldStr += MISC_KEY.FLAG + " " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n";

	/* TEXT SETTINGS */
	if (fontName != defaultFontName) {
		worldStr += TYPE_KEY.DEFAULT_FONT + " " + fontName + "\n";
		worldStr += "\n";
	}

	if (textDirection != TEXT_DIRECTION_KEY.LEFT_TO_RIGHT) {
		worldStr += TYPE_KEY.TEXT_DIRECTION + " " + textDirection + "\n";
		worldStr += "\n";
	}

	/* PALETTE */
	var paletteIdList = sortedIdList(palette);
	// NOTE: The -1 is because we don't store the entry at "0"
	var paletteCount = DEFAULT_REGISTRY_SIZE ? Math.min(DEFAULT_REGISTRY_SIZE - 1, paletteIdList.length) : paletteIdList.length;
	for (var i = 0; i < paletteCount; i++) {
		var id = paletteIdList[i];

		if (id === NULL_ID) {
			continue;
		}

		worldStr += serializePalette(id) + "\n";
	}

	/* ROOM */
	var roomIdList = sortedIdList(room);
	var roomCount = DEFAULT_REGISTRY_SIZE ? Math.min(DEFAULT_REGISTRY_SIZE - 1, roomIdList.length) : roomIdList.length;
	for (var i = 0; i < roomCount; i++) {
		var id = roomIdList[i];

		if (id === NULL_ID) {
			continue;
		}

		worldStr += serializeRoom(id) + "\n";
	}

	/* MAP */
	var mapIdList = sortedIdList(map);
	var mapCount = MAP_REGISTRY_SIZE ? Math.min(MAP_REGISTRY_SIZE - 1, mapIdList.length) : mapIdList.length;
	for (var i = 0; i < mapCount; i++) {
		var id = mapIdList[i];

		if (id === NULL_ID) {
			continue;
		}

		worldStr += serializeMap(id) + "\n";
	}

	/* TILES */
	var tileIdList = sortedIdList(tile);
	var tileCount = DEFAULT_REGISTRY_SIZE ? Math.min(DEFAULT_REGISTRY_SIZE - 1, tileIdList.length) : tileIdList.length;
	console.log("SERIALIZE TILES " + tileCount);
	for (var i = 0; i < tileCount; i++) {
		var id = tileIdList[i];

		if (id === NULL_ID) {
			continue;
		}

		worldStr += serializeTile(id) + "\n";
	}

	/* SCRIPTS */
	var scriptIdList = sortedIdList(dialog);
	var scriptCount = DEFAULT_REGISTRY_SIZE ? Math.min(DEFAULT_REGISTRY_SIZE, scriptIdList.length) : scriptIdList.length;
	for (var i = 0; i < scriptCount; i++) {
		var id = scriptIdList[i];

		if (id === NULL_ID) {
			continue;
		}

		var scriptRoot = scriptInterpreter.Parse(dialog[id].src, DialogWrapMode.No);
		var scriptFlat = scriptInterpreter.SerializeFlat(scriptRoot);
		var charCount = scriptFlat.length;

		if (SCRIPT_SIZE === null || charCount <= SCRIPT_SIZE) {
			worldStr += dialog[id].type + " " + id + "\n";
			worldStr += dialog[id].src + "\n";

			if (dialog[id].name != null) {
				worldStr += ARG_KEY.NAME + " " + dialog[id].name + "\n";
			}

			worldStr += "\n";
		}
	}

	/* VARIABLES */
	for (id in variable) {
		worldStr += CURLICUE_KEY.VARIABLE + " " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}

	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializePalette(id) {
	var out = "";

	out += TYPE_KEY.PALETTE + " " + id + "\n";

	var maxWritablePaletteSize = (PALETTE_SIZE ? (PALETTE_SIZE - WRITABLE_COLOR_START) : PALETTE_SIZE);

	var paletteSize = maxWritablePaletteSize ?
		Math.min(maxWritablePaletteSize, palette[id].colors.length) : palette[id].colors.length;

	for (var i = 0; i < paletteSize; i++) {
		var clr = palette[id].colors[i];
		out += toHex(clr) + "\n";
	}

	if (paletteSize < 3) {
		for (var i = 0; i < (3 - paletteSize); i++) {
			out += toHex([0, 0, 0]) + "\n";
		}
	}

	if (palette[id].name != null) {
		out += ARG_KEY.NAME + " " + palette[id].name + "\n";
	}

	return out;
}

function serializeRoom(id) {
	var out = "";

	out += TYPE_KEY.ROOM + " " + id + "\n";

	// make tilemap and overlay consistent
	var tilemap = createGrid(roomsize);
	var tileOverlay = []; // for extra tiles/sprites that don't fit in the grid

	for (var i = 0; i < roomsize; i++) {
		for (var j = 0; j < roomsize; j++) {
			var tileId = room[id].tilemap[i][j];
			var isIdShortEnough = (tileId.length <= 1 || flags.ROOM_FORMAT === 1);

			if (isIdShortEnough) {
				tilemap[i][j] = tileId;
			}
			else {
				tileOverlay.push({ x: j, y: i, id: tileId, });
			}
		}
	}

	for (var i = 0; i < room[id].tileOverlay.length; i++) {
		var tileLocation = room[id].tileOverlay[i];
		var isTileEmpty = (tilemap[tileLocation.y][tileLocation.x] === NULL_ID);
		var isIdShortEnough = (tileLocation.id.length <= 1 || flags.ROOM_FORMAT === 1);

		if (isTileEmpty && isIdShortEnough) {
			tilemap[tileLocation.y][tileLocation.x] = tileLocation.id;
		}
		else {
			tileOverlay.push({ x: tileLocation.x, y: tileLocation.y, id: tileLocation.id, });
		}
	}

	/* TILEMAP */
	for (var i = 0; i < roomsize; i++) {
		for (var j = 0; j < roomsize; j++) {
			out += tilemap[i][j];

			if (j < roomsize - 1 && flags.ROOM_FORMAT === 1) {
				out += LEGACY_KEY.SEPARATOR;
			}
		}

		out += "\n";
	}

	/* NAME */
	if (room[id].name != null) {
		out += ARG_KEY.NAME + " " + room[id].name + "\n";
	}

	/* PALETTE */
	if (room[id].pal != null && room[id].pal != NULL_ID) {
		out += TYPE_KEY.PALETTE + " " + room[id].pal + "\n";
	}

	/* TILE OVERLAY */
	for (var i = 0; i < tileOverlay.length; i++) {
		out += TYPE_KEY.TILE + " " + tileOverlay[i].id + " " + tileOverlay[i].x + " " + tileOverlay[i].y;
		out += "\n";
	}

	/* LEGACY WALL SETTINGS */
	if (room[id].walls.length > 0) {
		out += ARG_KEY.IS_WALL + " ";
		for (j in room[id].walls) {
			out += room[id].walls[j];
			if (j < room[id].walls.length - 1) {
				out += LEGACY_KEY.SEPARATOR;
			}
		}
		out += "\n";
	}

	return out;
}

function serializeMap(id) {
	var out = "";

	out += TYPE_KEY.MAP + " " + id + "\n";

	for (i in map[id].map) {
		for (j in map[id].map[i]) {
			out += map[id].map[i][j];
		}
		out += "\n";
	}

	if (map[id].name) {
		out += ARG_KEY.NAME + " " + map[id].name + "\n";
	}

	if (map[id].transition_effect_up) {
		out += ARG_KEY.TRANSITION_EFFECT_UP + " " + map[id].transition_effect_up + "\n";
	}

	if (map[id].transition_effect_down) {
		out += ARG_KEY.TRANSITION_EFFECT_DOWN + " " + map[id].transition_effect_down + "\n";
	}

	if (map[id].transition_effect_left) {
		out += ARG_KEY.TRANSITION_EFFECT_LEFT + " " + map[id].transition_effect_left + "\n";
	}

	if (map[id].transition_effect_right) {
		out += ARG_KEY.TRANSITION_EFFECT_RIGHT + " " + map[id].transition_effect_right + "\n";
	}

	return out;
}

function serializeTile(id) {
	var out = "";

	var type = tile[id].type;
	var isBackgroundTile = (type === TYPE_KEY.TILE);

	out += type + " " + id + "\n";
	out += serializeDrawing(id);

	if (tile[id].name != null && tile[id].name != undefined) {
		/* NAME */
		out += ARG_KEY.NAME + " " + tile[id].name + "\n";
	}

	if (ENABLE_COLOR_OVERRIDE && tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {
		var inValidRange = isColorIndexInValidRange(COLOR_INDEX.BACKGROUND + tile[id].bgc);
		if (inValidRange) {
			/* BACKGROUND COLOR OVERRIDE */
			out += ARG_KEY.BACKGROUND + " " + tile[id].bgc + "\n";
		}
	}

	if (ENABLE_COLOR_OVERRIDE && tile[id].col != null && tile[id].col != undefined) {
		var defaultColor = isBackgroundTile ? 1 : 2;
		var inValidRange = isColorIndexInValidRange(COLOR_INDEX.BACKGROUND + tile[id].col);
		if (tile[id].col != defaultColor && inValidRange) {
			/* COLOR OVERRIDE */
			out += ARG_KEY.COLOR +  " " + tile[id].col + "\n";
		}
	}

	if (isBackgroundTile && tile[id].isWall != null && tile[id].isWall != undefined && tile[id].isWall != false) {
		/* WALL */
		out += ARG_KEY.IS_WALL + " " + (tile[id].isWall ? BOOL_KEY.YES : BOOL_KEY.NO) + "\n";
	}

	if (!isBackgroundTile && tile[id].dlg != null) {
		out += ARG_KEY.DIALOG_SCRIPT + " " + tile[id].dlg + "\n";
	}

	if (!isBackgroundTile && tile[id].tickDlgId != null) {
		out += ARG_KEY.FRAME_TICK_SCRIPT + " " + tile[id].tickDlgId + "\n";
	}

	if (!isBackgroundTile && tile[id].knockDlgId != null) {
		out += ARG_KEY.KNOCK_INTO_SCRIPT + " " + tile[id].knockDlgId + "\n";
	}

	if (!isBackgroundTile && tile[id].buttonDownDlgId != null) {
		out += ARG_KEY.BUTTON_DOWN_SCRIPT + " " + tile[id].buttonDownDlgId + "\n";
	}

	if (type === TYPE_KEY.SPRITE && id === playerId && tile[id].inventory != null) {
		for (itemId in tile[id].inventory) {
			out += TYPE_KEY.ITEM + " " + itemId + " " + tile[id].inventory[itemId] + "\n";
		}
	}

	if (type === TYPE_KEY.EXIT && tile[id].dest.room != null) {
		out += ARG_KEY.EXIT_DESTINATION + " " + tile[id].dest.room + " " + tile[id].dest.x + " " + tile[id].dest.y + "\n";
	}

	if (type === TYPE_KEY.EXIT && tile[id].transition_effect != null) {
		out += ARG_KEY.TRANSITION_EFFECT + " " + tile[id].transition_effect + "\n";
	}

	if ((type === TYPE_KEY.EXIT || type === TYPE_KEY.ENDING) && tile[id].lockItem != null) {
		out += ARG_KEY.LOCK + " " + tile[id].lockItem + "\n";
	}

	return out;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetTileSource(drwId);
	var drwStr = "";

	var frameCount = ANIMATION_SIZE === null ?
		imageSource.length : Math.min(ANIMATION_SIZE, imageSource.length);

	for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
		for (y in imageSource[frameIndex]) {
			var rowStr = "";

			for (x in imageSource[frameIndex][y]) {
				rowStr += imageSource[frameIndex][y][x];
			}

			drwStr += rowStr + "\n";
		}

		if (frameIndex < (frameCount - 1)) {
			drwStr += (MISC_KEY.NEXT + "\n");
		}
	}

	return drwStr;
}

} // Parser
</script>

<script>
var PALETTE_ID = {
	ROOM : 0,
	PREV : 1,
	FADE : 2,
};

function Color() {
	// active palette colors
	var activePalettes = {};

	var colorCycleOffset = 0;
	var colorCycleMin = 2;
	var colorCycleLen = 10;

	function CreateDefaultPalette() {
		var palette = [];

		// text box colors
		palette.push([0,0,0,255]);
		palette.push([255,255,255,255]);

		// precalculated rainbow colors
		palette.push([255,0,0,255]);
		palette.push([255,217,0,255]);
		palette.push([78,255,0,255]);
		palette.push([0,255,125,255]);
		palette.push([0,192,255,255]);
		palette.push([0,18,255,255]);
		palette.push([136,0,255,255]);
		palette.push([255,0,242,255]);
		palette.push([255,0,138,255]);
		palette.push([255,0,61,255]);

		// transparent
		palette.push([0,0,0,0]);

		// default tile colors
		palette.push([0,0,0,255]);
		palette.push([255,255,255,255]);
		palette.push([255,255,255,255]);

		return palette;
	}

	// set palette to default colors
	function ResetRoomPalette() {
		activePalettes[PALETTE_ID.ROOM] = CreateDefaultPalette();
	}

	// todo : name?
	function ShiftedColorIndex(palId, index) {
		var offset = (palId in palette) ? palette[palId].indexOffset : COLOR_INDEX.BACKGROUND;
		var shiftedIndex = index + offset;

		if (PALETTE_SIZE) {
			shiftedIndex = shiftedIndex % PALETTE_SIZE;
		}

		return shiftedIndex;
	}
	this.ShiftedColorIndex = ShiftedColorIndex;

	this.LoadRoomPalette = function(pal) {
		ResetRoomPalette();

		var palette = activePalettes[PALETTE_ID.ROOM];

		if (pal != undefined && pal != null) {
			for (var i = 0; i < pal.colors.length; i++) {
				var index = ShiftedColorIndex(pal.id, i);
				var alpha = (index === COLOR_INDEX.TRANSPARENT) ? 0 : 255;

				if (index < palette.length) {
					palette[index] = pal.colors[i].concat([alpha]);
				}
				else {
					palette.push(pal.colors[i].concat([alpha]));
				}
			}
		}
	};

	this.RoomPaletteSize = function() {
		return activePalettes[PALETTE_ID.ROOM] ? activePalettes[PALETTE_ID.ROOM].length : 0;
	};

	this.StoreRoomPalette = function() {
		activePalettes[PALETTE_ID.PREV] = activePalettes[PALETTE_ID.ROOM];
	};

	this.CreateFadePalette = function(clearIndex) {
		activePalettes[PALETTE_ID.FADE] = [];

		for (var i = 0; i < activePalettes[PALETTE_ID.ROOM].length; i++) {
			activePalettes[PALETTE_ID.FADE].push(activePalettes[PALETTE_ID.PREV][clearIndex]);
		}
	};

	function UpdateSystemPalette(paletteIdA, paletteIdB, delta) {
		if (paletteIdA === undefined || paletteIdA === null) {
			paletteIdA = PALETTE_ID.ROOM;
		}

		bitsyPaletteRequestSize(activePalettes[paletteIdA].length); // todo : do this on every update?

		if (paletteIdB != undefined && paletteIdB != null && delta != undefined && delta != null) {
			for (var i = 0; i < activePalettes[paletteIdA].length; i++) {
				var colorA = activePalettes[paletteIdA][i];

				var colorB = (i < activePalettes[paletteIdB].length) ?
					activePalettes[paletteIdB][i] : activePalettes[paletteIdB][COLOR_INDEX.BACKGROUND];

				var deltaColor = LerpColor(colorA, colorB, delta);

				bitsyPaletteSetColor(i, deltaColor[0], deltaColor[1], deltaColor[2], deltaColor[3]);
			}
		}
		else {
			for (var i = 0; i < activePalettes[paletteIdA].length; i++) {
				var color = activePalettes[paletteIdA][i];
				bitsyPaletteSetColor(i, color[0], color[1], color[2], color[3]);
			}
		}
	}
	this.UpdateSystemPalette = UpdateSystemPalette;

	function LerpColor(colorA, colorB, delta) {
		return [colorA[0] + ((colorB[0] - colorA[0]) * delta),
			colorA[1] + ((colorB[1] - colorA[1]) * delta),
			colorA[2] + ((colorB[2] - colorA[2]) * delta),
			colorA[3] + ((colorB[3] - colorA[3]) * delta)];
	}

	function GetColorIndex(index) {
		// todo : handle index out of bounds?

		if (index >= colorCycleMin && index < (colorCycleMin + colorCycleLen)) {
			index -= colorCycleMin;
			index = (index + colorCycleOffset) % colorCycleLen;
			index += colorCycleMin;
		}

		return index;
	}
	this.GetColorIndex = GetColorIndex;

	function GetColor(index, id) {
		var palette = activePalettes[id ? id : PALETTE_ID.ROOM];

		var i = GetColorIndex(index);

		if (i < 0 || index >= palette.length) {
			i = COLOR_INDEX.BACKGROUND;
		}

		return palette[i];
	};
	this.GetColor = GetColor;

	this.Cycle = function() {
		colorCycleOffset--;

		if (colorCycleOffset < 0) {
			colorCycleOffset = colorCycleLen - 1;
		}
	}

	this.GetDefaultColor = function(index) {
		var defaultPalette = CreateDefaultPalette();

		return index >= defaultPalette.length ? [0,0,0,0] : CreateDefaultPalette()[index];
	}

	this.GetDefaultPalette = function() {
		return CreateDefaultPalette();
	}

	ResetRoomPalette();
	UpdateSystemPalette();
}

function fromHex(hexStr) {
	var r = parseInt(hexStr.substring(0, 2), 16);
	var g = parseInt(hexStr.substring(2, 4), 16);
	var b = parseInt(hexStr.substring(4, 6), 16);
	return [r, g, b];
}

function toHex(rgbArr) {
	var r = rgbArr[0].toString(16).toUpperCase().padStart(2, '0');
	var g = rgbArr[1].toString(16).toUpperCase().padStart(2, '0');
	var b = rgbArr[2].toString(16).toUpperCase().padStart(2, '0');
	return r + "" + g + "" + b;
}

// really just a vector distance
function colorDistance(a1, b1, c1, a2, b2, c2) {
	return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === MISC_KEY.COMMENT) {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == TYPE_KEY.FONT) {
					name = args[1];
				}
				else if (args[0] === FONT_KEY.SIZE) {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] === FONT_KEY.CHARACTER_START) {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");

					if (args[0] === FONT_KEY.CHARACTER_SIZE) {
						// Custom character size - overrides the default character size for the font
						chardata[curCharCode].width = parseInt(args[1]);
						chardata[curCharCode].height = parseInt(args[2]);
						chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
					}
					else if (args[0] === FONT_KEY.CHARACTER_OFFSET) {
						// Character offset - shift the origin of the character on the X or Y axis
						chardata[curCharCode].offset.x = parseInt(args[1]);
						chardata[curCharCode].offset.y = parseInt(args[2]);
					}
					else if (args[0] === FONT_KEY.CHARACTER_SPACING) {
						// Character spacing:
						// specify total horizontal space taken up by the character
						// lets chars take up more or less space on a line than its bitmap does
						chardata[curCharCode].spacing = parseInt(args[1]);
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push(parseInt(line[j]));
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
var TransitionManager = function() {
	var curEffect = null;

	var transitionStart = null;
	var transitionEnd = null;
	var transitionTextureId = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectId, onInitNextRoom) {
		curEffect = null;

		if (effectId in transitionEffects) {
			curEffect = transitionEffects[effectId];
		}

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (curEffect.showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			// todo : will this break anything?
			player().x = -1;
			player().y = -1;
		}

		var startBuffer = (curEffect.type === EffectType.Tile) ? renderer.CreateTileBufferTarget() : renderer.CreateBufferTarget();
		drawRoom(room[startRoom], { target: startBuffer, });
		transitionStart = new TransitionInfo(startBuffer, PALETTE_ID.PREV, startX, startY);

		if (curEffect.showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().x = -1;
			player().y = -1;
		}

		onInitNextRoom(endRoom);

		var endBuffer = (curEffect.type === EffectType.Tile) ? renderer.CreateTileBufferTarget() : renderer.CreateBufferTarget();
		drawRoom(room[endRoom], { target: endBuffer, });
		transitionEnd = new TransitionInfo(endBuffer, PALETTE_ID.ROOM, endX, endY);

		var textureSize = roomsize * tilesize * scale;
		transitionTextureId = bitsyTextureCreate(textureSize, textureSize);

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;

		// set palette for clearing screen
		if ("clearIndex" in curEffect) {
			color.CreateFadePalette(curEffect.clearIndex);
		}
	}

	function EndTransition() {
		curEffect = null;

		isTransitioning = false;
		transitionTime = 0;
		transitionStart = null;
		transitionEnd = null;
		prevStep = -1;

		bitsyTextureRelease(transitionTextureId);
		transitionTextureId = null;

		color.UpdateSystemPalette();

		if (transitionCompleteCallback != null) {
			transitionCompleteCallback();
		}
		transitionCompleteCallback = null;
	}

	this.Cancel = function() {
		EndTransition();
	};

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / curEffect.duration;
		var maxStep = Math.floor(frameRate * (curEffect.duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			if ("type" in curEffect && curEffect.type === EffectType.Tile) {
				UpdateTileEffect(curEffect, step, maxStep);
			}
			else {
				UpdatePixelEffect(curEffect, step, maxStep);
			}
		}

		prevStep = step;

		if (transitionTime >= curEffect.duration) {
			EndTransition();
		}
	}

	// todo : pass in other parameters?
	function UpdatePixelEffect(effect, step, maxStep) {
		effect.onStep(transitionStart, transitionEnd, (step / maxStep));

		for (var y = 0; y < transitionStart.Buffer.Height; y++) {
			for (var x = 0; x < transitionStart.Buffer.Width; x++) {

				var effectColorIndex = effect.pixelEffectFunc(
					transitionStart,
					transitionEnd,
					x,
					y,
					(step / maxStep));

				bitsyTextureSetPixel(transitionTextureId, x, y, scale, effectColorIndex);
			}
		}

		bitsyCanvasPutTexture(transitionTextureId, 0, 0);
	}

	function UpdateTileEffect(effect, step, maxStep) {
		renderer.ResetRenderCache();

		// kind of hacky (?) way to allow drawing to empty spaces during transitions
		renderer.SetTileSource(NULL_ID, createGrid(tilesize, 0));

		effect.onStep(transitionStart, transitionEnd, (step / maxStep));

		var screenTarget = renderer.CreateScreenTarget();
		screenTarget.Clear();

		for (var y = 0; y < transitionStart.Buffer.Height; y++) {
			for (var x = 0; x < transitionStart.Buffer.Width; x++) {
				var drawing = effect.tileEffectFunc(transitionStart, transitionEnd, x, y, step);
				screenTarget.DrawSprite(drawing, x, y);
			}
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	// todo : name? // todo : remove?
	this.RegisterTransitionEffect("NONE", {
		showPlayerStart : false,
		showPlayerEnd : false,
		duration : 500,
		onStep : function() {},
		pixelEffectFunc : function() {},
	});

	function onStepFade(start, end, delta) {
		var palIdA = delta < 0.5 ? start.PaletteId : PALETTE_ID.FADE;
		var palIdB = delta < 0.5 ? PALETTE_ID.FADE : end.PaletteId;

		delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

		color.UpdateSystemPalette(palIdA, palIdB, delta);
	}

	function pixelEffectFade(start, end, pixelX, pixelY, delta) {
		var curBuffer = delta < 0.5 ? start.Buffer : end.Buffer;
		return curBuffer.GetPixel(pixelX, pixelY);
	}

	this.RegisterTransitionEffect(TRANSITION_KEY.FADE_WHITE, { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		clearIndex : COLOR_INDEX.TEXT,
		onStep : onStepFade,
		pixelEffectFunc : pixelEffectFade,
	});

	this.RegisterTransitionEffect(TRANSITION_KEY.FADE_BLACK, {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		clearIndex : COLOR_INDEX.TEXTBOX,
		onStep : onStepFade,
		pixelEffectFunc : pixelEffectFade,
	});

	// todo : name? WVY? WAV?
	this.RegisterTransitionEffect(TRANSITION_KEY.WAVE, {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		onStep : function(start, end, delta) {
			var curPalId = delta < 0.5 ? start.PaletteId : end.PaletteId;
			color.UpdateSystemPalette(curPalId);
		},
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Buffer.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Buffer.Width;
			}
			else if (pixelX >= start.Buffer.Width) {
				pixelX -= start.Buffer.Width;
			}

			var curBuffer = delta < 0.5 ? start.Buffer : end.Buffer;
			return curBuffer.GetPixel(pixelX, pixelY);
		},
	});

	this.RegisterTransitionEffect(TRANSITION_KEY.TUNNEL, {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		onStep : function(start, end, delta) {
			if (delta <= 0.4) {
				color.UpdateSystemPalette(start.PaletteId);
			}
			else if (delta <= 0.6) {
				var paletteDelta = (delta - 0.4) / 0.2;
				color.UpdateSystemPalette(start.PaletteId, end.PaletteId, paletteDelta);
			}
			else {
				color.UpdateSystemPalette(end.PaletteId);
			}
		},
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var palIndex = COLOR_INDEX.TEXTBOX;

			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				var palIndex = COLOR_INDEX.TEXTBOX;

				if (dist > start.Buffer.Width * tunnelDelta) {
					// do nothing
				}
				else {
					palIndex = start.Buffer.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return COLOR_INDEX.TEXTBOX;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Buffer.Width * tunnelDelta) {
					// do nothing
				}
				else {
					palIndex = end.Buffer.GetPixel(pixelX, pixelY);
				}
			}

			return palIndex;
		},
	});

	function onStepSlide(start, end, delta) {
		var paletteDelta = clampLerp(delta, 0.4);
		color.UpdateSystemPalette(start.PaletteId, end.PaletteId, paletteDelta);
	}

	this.RegisterTransitionEffect(TRANSITION_KEY.SLIDE_UP, {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		onStep: onStepSlide,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Buffer.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Buffer.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Buffer.Height;
				return end.Buffer.GetPixel(pixelX, slidePixelY);
			}
		},
	});

	this.RegisterTransitionEffect(TRANSITION_KEY.SLIDE_DOWN, {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		onStep: onStepSlide,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Buffer.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Buffer.Height) {
				return start.Buffer.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Buffer.Height;
				return end.Buffer.GetPixel(pixelX, slidePixelY);
			}
		},
	});

	this.RegisterTransitionEffect(TRANSITION_KEY.SLIDE_LEFT, {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		onStep: onStepSlide,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Buffer.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Buffer.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Buffer.Width;
				return end.Buffer.GetPixel(slidePixelX, pixelY);
			}
		},
	});

	this.RegisterTransitionEffect(TRANSITION_KEY.SLIDE_RIGHT, {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		onStep: onStepSlide,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Buffer.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Buffer.Width) {
				return start.Buffer.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Buffer.Width;
				return end.Buffer.GetPixel(slidePixelX, pixelY);
			}
		},
	});

	var EffectType = {
		Pixel : 0,
		Tile : 0,
	};

	// TODO : WIP prototype
	// function CreateTileEffect() {
	// 	var script = // TODO

	// 	function CreateTileInfoTable(tileInfo) {
	// 		var table = new Table();
	// 		table.Set("DRW", tileInfo.drw);
	// 		table.Set("COL", tileInfo.col);
	// 		table.Set("BGC", tileInfo.bgc);
	// 		return table;
	// 	}

	// 	var effect = {
	// 		type : EffectType.Tile,
	// 		showPlayerStart : false,
	// 		showPlayerEnd : true,
	// 		duration : 1000,
	// 		onStep : function(start, end, delta) {
	// 			color.UpdateSystemPalette(start.PaletteId, end.PaletteId, delta);
	// 		},
	// 		tileEffectFunc : function(start, end, tileX, tileY, step) {
	// 			var result = {
	// 				drw: "0",
	// 				col: 0,
	// 				bgc: 0,
	// 				colorOffset: COLOR_INDEX.BACKGROUND,
	// 				animation: { isAnimated: false, frameIndex: 0, frameCount: 1, },
	// 			};

	// 			var startTile = CreateTileInfoTable(start.Buffer.GetTile(tileX, tileY));
	// 			var endTile = CreateTileInfoTable(end.Buffer.GetTile(tileX, tileY));

	// 			scriptInterpreter.RunCallback(
	// 				script,
	// 				null,
	// 				[tileX, tileY, startTile, endTile, step], // param order?
	// 				function(out) {
	// 					if (out) {
	// 						if (out.Has("DRW")) {
	// 							result.drw = out.Get("DRW");
	// 						}

	// 						if (out.Has("COL")) {
	// 							result.col = out.Get("COL");
	// 						}

	// 						if (out.Has("BGC")) {
	// 							result.bgc = out.Get("BGC");
	// 						}
	// 					}
	// 				});

	// 			if (result.drw in tile) {
	// 				// todo : will this cause any bugs to access the global animation state?
	// 				result.animation = tile[result.drw].animation;
	// 			}

	// 			return result;
	// 		},
	// 	};

	// 	return effect;
	// }

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}
}; // TransitionManager()

var TransitionInfo = function(pixelBuffer, paletteId, playerX, playerY) {
	this.Buffer = pixelBuffer;
	this.PaletteId = paletteId;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
function Library() {

// todo : extend table so this doesn't have to be custom?
function createGlobalEnvironment(variableStore) {
	var env = {
		Has: function(key) {
			return variableStore.hasOwnProperty(key);
		},
		Get: function(key) {
			if (variableStore.hasOwnProperty(key)) {
				return variableStore[key];
			}

			return false;
		},
		Set: function(key, value) {
			variableStore[key] = value;

			if (onVariableChanged) {
				onVariableChanged(key);
			}

			return value;
		},
	};

	return env;
}

function createInstanceEnvironment(instance, parent) {
	var env = new Table(parent);
	env.Set(ENTRY_KEY.THIS_SPRITE, instance);
	return env;
}

function createCoreLibrary(parent) {
	var lib = new Table(parent);

	// todo : allow name as input
	lib.Set("ITM", function(parameters, onReturn) {
		var itemId = parameters[0];

		var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

		if (parameters.length > 1) {
			// TODO : is it a good idea to force inventory to be >= 0?
			player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
			curItemCount = player().inventory[itemId];

			if (onInventoryChanged != null) {
				onInventoryChanged(itemId);
			}
		}

		onReturn(curItemCount);
	});

	return lib;
}

// TODO : do I want these? what should the final version be?
function coreLibWIP(parent) {
	// todo : what about OTHER one parameter math functions? cos? sin? etc...
	// todo : do I want both NOT and ISNT? how do I surface NOT if not thru math editor
	lib.Set("NOT", function(parameters, onReturn) {
		onReturn(!parameters[0]);
	});

	// WIP --- for loops, range, and random for tables
	// todo :
	// should I also have NTH and LEN? or have them instead?
	// if keys are strings... they can't be used to update the table!
	// other ideas: NK == nth key, NV == nth value
	lib.Set("FOR", function(parameters, onReturn) {
		// todo : verify the inputs are correct
		var table = parameters[0];
		var fn = parameters[1];

		var keys = table.Keys();
		var i = 0;
		var evalNext;

		evalNext = function() {
			if (i >= keys.length) {
				onReturn(false);
			}
			else {
				var k = keys[i];
				var v = table.Get(k);

				fn([v, k], function() {
					i++;
					evalNext();
				});
			}
		};

		evalNext();
	});

	// todo : should max be inclusive or exclusive? look at other langs
	lib.Set("RNG", function(parameters, onReturn) {
		var min = parameters[0];
		var max = parameters[1];
		var index = 0;
		var table = new Table();

		for (var i = min; i < max; i++) {
			table.Set("" + index, i);
			index++;
		}

		onReturn(table);
	});

	lib.Set("RND", function(parameters, onReturn) {
		var table = parameters[0];
		var keys = table.Keys();
		var k = keys[Math.floor(Math.random() * keys.length)];
		onReturn(table.Get(k));
	});
}

// todo : is this the right place for this?
function valueToString(value) {
	var str = "";

	console.log(typeof value);

	if (typeof value === "function") {
		str += CURLICUE_KEY.FUNCTION;
	}
	else if (IsATable(value)) {
		if (value.Has(ENTRY_KEY.SPRITE_NAME)) {
			str += valueToString(value.Get(ENTRY_KEY.SPRITE_NAME));
		}
		else if (value.Has(ENTRY_KEY.SPRITE_TYPE) && value.Has(ENTRY_KEY.SPRITE_ID)) {
			str += valueToString(value.Get(ENTRY_KEY.SPRITE_TYPE)) + " " + valueToString(value.Get(ENTRY_KEY.SPRITE_ID));
		}
		else {
			str += CURLICUE_KEY.TABLE;
		}
	}
	else if ((typeof value === "boolean") || value === undefined || value === null) {
		str += (value ? BOOL_KEY.YES : BOOL_KEY.NO);
	}
	else if ((typeof value === "string") || (typeof value === "number")) {
		str += value;
	}
	else {
		str += BOOL_KEY.NO;
	}

	return str;
}

function createDialogLibrary(dialogBuffer, parent) {
	var lib = new Table(parent);

	lib.Set("SAY", function(parameters, onReturn) {
		// todo : is this the right implementation of say?
		// todo : hacky to force into a string with concatenation?
		// todo : nicer way to print tables
		// todo : new way to convert bools etc to string
		dialogBuffer.AddText(valueToString(parameters[0]));
		dialogBuffer.AddScriptReturn(onReturn);
	});

	// todo : should it be the drawing ID or tile ID?
	lib.Set("DRW", function(parameters, onReturn) {
		dialogBuffer.AddDrawing(parameters[0]);
		dialogBuffer.AddScriptReturn(onReturn);
	});

	lib.Set("BR", function(parameters, onReturn) {
		dialogBuffer.AddLinebreak();
		dialogBuffer.AddScriptReturn(onReturn);
	});

	lib.Set("PG", function(parameters, onReturn) {
		// TODO : fix this method...
		dialogBuffer.AddPagebreak();
		dialogBuffer.AddScriptReturn(onReturn);
	});

	var textEffectIds = ["WVY", "SHK", "RBW", "CLR",];

	function addTextEffect(id) {
		lib.Set(id, function(parameters, onReturn) {
			dialogBuffer.AddTextEffect(id, parameters);
			onReturn(false);
		});

		lib.Set("/" + id, function(parameters, onReturn) {
			dialogBuffer.RemoveTextEffect(id);
			onReturn(false);
		});
	};

	for (var i = 0; i < textEffectIds.length; i++) {
		addTextEffect(textEffectIds[i]);
	}

	// add secret dialog buffer entry for use by dialog expressions & choices
	lib.SetSecret("DIALOG_BUFFER", dialogBuffer);

	return lib;
}

function createRoomLibrary(dialogBuffer, dialogRenderer, parent) {
	var lib = new Table(parent);

	lib.Set("PAL", function(parameters, onReturn) {
		var palId = parameters[0];

		// todo -- should there be a helper function that combines these three functions?
		color.LoadRoomPalette(palette[palId]);
		color.UpdateSystemPalette();
		renderer.ResetRenderCache();

		onReturn(false); // todo : return palette id?
	});

	// todo : allow names instead of IDs
	lib.Set("EXT", function(parameters, onReturn) {
		var destRoom = parameters[0];
		var destX = parseInt(parameters[1]);
		var destY = parseInt(parameters[2]);
		var transitionEffect = parameters.length >= 4 ? parameters[3] : null;
		var waitForInput = parameters.length >= 5 ? parameters[4] : true;

		function beginExit() {
			// todo : share some of this logic with regular exits?
			if (transitionEffect != null) {
				transition.BeginTransition(
					player().room,
					player().x,
					player().y,
					destRoom,
					destX,
					destY,
					transitionEffect,
					initRoom);

				transition.UpdateTransition(0);
			}
			else {
				initRoom(destRoom);
			}

			player().room = destRoom;
			player().x = destX;
			player().y = destY;
			curRoom = destRoom;

			// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
			if (transition.IsTransitionActive()) {
				transition.OnTransitionComplete(function() { onReturn(false); });
			}
			else {
				onReturn(false);
			}
		}

		if (waitForInput && dialogBuffer && dialogBuffer.IsActive()) {
			dialogBuffer.AddPagebreak();
			dialogBuffer.AddScriptReturn(beginExit);
		}
		else {
			beginExit();
		}
	});

	lib.Set("END", function(parameters, onReturn) {
		var waitForInput = parameters.length >= 1 ? parameters[0] : true;

		function beginEnding() {
			// todo very global / hacky?
			isEnding = true;
			isNarrating = true;
			dialogRenderer.SetCentered(true);

			onReturn(false);
		}

		if (waitForInput && dialogBuffer && dialogBuffer.IsActive()) {
			dialogBuffer.AddPagebreak();
			dialogBuffer.AddScriptReturn(beginEnding);
		}
		else {
			beginEnding();
		}
	});

	return lib;
}

function createSpriteLibrary(contextInstance, parent) {
	var lib = new Table(parent);

	// NEW FUNCTIONS (WIP)

	// create new sprite instance
	lib.Set("PUT", function(parameters, onReturn) {
		var instance = null;

		// todo : what if there's no parameters[0]?
		var location = createSpriteLocation(parameters[0], 0, 0);

		if (parameters.length >= 3) {
			location.x = parameters[1];
			location.y = parameters[2];
		}
		else if (contextInstance != undefined && contextInstance != null) {
			// todo : what if the context instance is invalid now?
			location.x = contextInstance.x; // todo : upper?
			location.y = contextInstance.y;
		}

		var instanceId = toB256(instanceCount);
		instance = createSpriteInstance(instanceId, location);
		spriteInstances[instanceId] = instance;
		instanceCount++;

		onReturn(instance);
	});

	// remove sprite instance
	lib.Set("RID", function(parameters, onReturn) {
		// todo : allow deleting the current sprite if no parameters?
		// todo : what if the sprite passed in is no longer valid?
		if (parameters.length >= 1 && "instanceId" in parameters[0]) {
			delete spriteInstances[parameters[0].instanceId];
		}

		onReturn(false);
	});

	// move a sprite instance (with collisions)
	lib.Set("HOP", function(parameters, onReturn) {
		// todo : allow moving the current sprite if no parameters? that would mean putting the reference param last
		// todo : check that the instance is a valid object instance!
		var instance = parameters[0];
		var result = !move(instance, parameters[1]).collision;

		onReturn(result);
	});

	return lib;
}

function createMathLibrary(parent) {
	var lib = new Table(parent);

	lib.Set("IS", function(parameters, onReturn) {
		onReturn(parameters[0] === parameters[1]);
	});

	lib.Set("ISNT", function(parameters, onReturn) {
		onReturn(parameters[0] != parameters[1]);
	});

	lib.Set("GT", function(parameters, onReturn) {
		onReturn(parameters[0] > parameters[1]);
	});

	lib.Set("LT", function(parameters, onReturn) {
		onReturn(parameters[0] < parameters[1]);
	});

	lib.Set("GTE", function(parameters, onReturn) {
		onReturn(parameters[0] >= parameters[1]);
	});

	lib.Set("LTE", function(parameters, onReturn) {
		onReturn(parameters[0] <= parameters[1]);
	});

	// TODO : should these allow multiple arguments?
	// TODO : use math symbols for any of these? > < == * / + -
	lib.Set("MLT", function(parameters, onReturn) {
		onReturn(parameters[0] * parameters[1]);
	});

	lib.Set("DIV", function(parameters, onReturn) {
		onReturn(parameters[0] / parameters[1]);
	});

	lib.Set("ADD", function(parameters, onReturn) {
		onReturn(parameters[0] + parameters[1]);
	});

	// todo : potentially using "SUB" instead "-" frees up "-" to be the dialog start symbal
	lib.Set("SUB", function(parameters, onReturn) {
		onReturn(parameters[0] - parameters[1]);
	});

	return lib;
}

// todo : is this a good way to do this?
this.IsMathExpression = (function() {
	var mathLibKeys = createMathLibrary().Keys();
	return function(symbol) {
		return mathLibKeys.indexOf(symbol) != -1;
	};
})();

this.CreateScriptEnvironment = function(variable, dialogBuffer, instance) {
	var globalEnv = createGlobalEnvironment(variable);
	var coreLibrary = createCoreLibrary(globalEnv);
	var dialogLibrary = createDialogLibrary(dialogBuffer, coreLibrary);
	var roomLibrary = createRoomLibrary(dialogBuffer, dialogRenderer, dialogLibrary);
	var spriteLibrary = createSpriteLibrary(instance, roomLibrary);
	var mathLibrary = createMathLibrary(spriteLibrary); // todo : why is this one last?
	var instanceEnv = createInstanceEnvironment(instance, mathLibrary);

	return instanceEnv;
};

}
</script>

<script>
var DialogWrapMode = {
	Auto : 0,
	Yes : 1,
	No : 2,
};

function CurlicueScript() {

var compiledScripts = {};

function compile(script, options) {
	var doNotStore = options && options.doNotStore;

	var dialogWrapMode =
		(options && "dialogWrapMode" in options) ? options.dialogWrapMode : DialogWrapMode.Auto;

	var scriptStr = script.src;
	if (dialogWrapMode != DialogWrapMode.No && (dialogWrapMode === DialogWrapMode.Yes || scriptStr.indexOf("\n") < 0)) {
		// wrap one-line dialogs in a dialog expression
		// TODO : is this still what I want?
		scriptStr = CURLICUE_KEY.OPEN + CURLICUE_KEY.DIALOG + " " + scriptStr + CURLICUE_KEY.CLOSE;
	}

	var tokens = tokenize(scriptStr);
	var expressions = parse(tokens);
	var rootExpression = expressions[0];

	if (!doNotStore) {
		compiledScripts[script.id] = rootExpression;
	}

	return rootExpression;
}
this.Compile = compile;

// temporary parsing... not sure about this implementation..
this.Parse = function(scriptSrc, dialogWrapMode) {
	return compile(
		{ src: scriptSrc, id: null },
		{ doNotStore: true, dialogWrapMode: dialogWrapMode });
}

// TODO : pass in dialog buffer instead of using a global reference?
this.Run = function(script, instance, callback) {
	if (!(script.id in compiledScripts)) {
		compile(script);
	}

	// todo : lots of globals..
	var env = library.CreateScriptEnvironment(variable, dialogBuffer, instance);

	eval(compiledScripts[script.id], env, callback);
}

var RunFunction = function(script, instance, inputParameters, callback) {
	this.Run(script, instance, function(result) {
		if (result instanceof Function) {
			result(inputParameters, callback);
		}
		else {
			callback(result);
		}
	});
}
this.RunFunction = RunFunction;

// do I want a monolithic reset function like this?
this.Reset = function() {
	compiledScripts = {};
}

var indentStep = 4;

function serializeSingle(expressionList, indentDepth) {
	var out = "";

	for (var i = 0; i < expressionList.length; i++) {
		if (i > 0) {
			out += " ";
		}

		out += serialize(expressionList[i], indentDepth + indentStep); // todo : need the increase in indent?
	}

	return out;
}

function serializeMulti(expressionList, indentDepth, startBreakIndex) {
	if (startBreakIndex === undefined || startBreakIndex === null) {
		startBreakIndex = 0;
	}

	var out = "";

	for (var i = 0; i < expressionList.length; i++) {
		if (i > startBreakIndex) {
			out += "\n" + (" ".repeat(indentDepth + indentStep));
		}
		else if (i > 0) {
			out += " ";
		}

		out += serialize(expressionList[i], indentDepth + indentStep);
	}

	return out;
}

function serializeAlternating(expressionList, indentDepth) {
	var out = "";

	for (var i = 0; i < expressionList.length; i++) {
		var isChoiceResult = i > 0 && (i - 1) % 2 != 0;
		var indentNext = indentDepth + indentStep + (isChoiceResult ? indentStep : 0);

		if (i > 0) {
			out += "\n" + (" ".repeat(indentNext));
		}

		out += serialize(expressionList[i], indentNext);
	}

	return out;
}

function serializePaired(expressionList, indentDepth) {
	var out = "";

	for (var i = 0; i < expressionList.length; i++) {
		if (i > 0 && (i - 1) % 2 === 0) {
			out += "\n" + (" ".repeat(indentDepth + indentStep));
		}
		else if (i > 0) {
			out += " ";
		}

		out += serialize(expressionList[i], indentDepth + indentStep);
	}

	return out;	
}

// todo : should "SAY" be inline? "PG"?
function isInlineFunction(symbol) {
	return ["BR", "PG", "WVY", "/WVY", "SHK", "/SHK", "RBW", "/RBW", "CLR", "/CLR", "DRW"].indexOf(symbol) != -1;
}
this.IsInlineFunction = isInlineFunction;

var wordWrapLen = 32; // hard coded to match default bitsy font -- make it more flexible later?

function serializeWrapped(expressionList, indentDepth) {
	var indentNext = 0;

	if (indentDepth != undefined && indentDepth != null) {
		indentNext = indentDepth + indentStep;
	}

	var out = "";

	var curLineLen = 0;
	var prevLineIsMultiLine = false;

	for (var i = 0; i < expressionList.length; i++) {
		var exp = expressionList[i];
		var expStr = serialize(expressionList[i], indentNext);
		var nextWordLen = exp.type != "list" && exp.value != CURLICUE_KEY.DIALOG ? expStr.length : 0;
		var isMultiLine = exp.type === "list" && !isInlineFunction(exp.list[0].value);

		if (prevLineIsMultiLine || isMultiLine || (curLineLen + nextWordLen + 1) > wordWrapLen) {
			out += "\n" + (" ".repeat(indentNext));
			curLineLen = 0;
		}
		else if (i > 0) {
			out += " ";
			curLineLen++;
		}

		prevLineIsMultiLine = isMultiLine;
		curLineLen += nextWordLen;

		out += expStr;
	}

	return out;
}
this.SerializeWrapped = serializeWrapped;

function serializeUnwrapped(expression) {
	var out = "";

	if (expression.type === "list" && expression.list[0].value === CURLICUE_KEY.DIALOG) {
		out = serializeWrapped(expression.list.slice(1));
	}

	return out.trim();
}
this.SerializeUnwrapped = serializeUnwrapped;

function isDialogExpression(symbol) {
	return symbol === CURLICUE_KEY.DIALOG;
}
this.IsDialogExpression = isDialogExpression;

function isSequence(symbol) {
	return ["SEQ", "CYC", "SHF"].indexOf(symbol) != -1;
}
this.IsSequence = isSequence;

function isChoice(symbol) {
	return symbol === "PIK";
}
this.IsChoice = isChoice;

function isConditional(symbol) {
	return symbol === "IF";
}
this.IsConditional = isConditional;

function isTable(symbol) {
	return symbol === "TBL";
}
this.IsTable = isTable;

function isFunctionDefinition(symbol) {
	return symbol === "FN";
}
this.IsFunctionDefinition = isFunctionDefinition;

// todo : nicer formatting for asignment to multiline lists?
function serializeList(expression, indentDepth) {
	var listType = null;
	if (expression.list.length > 0 && expression.list[0].type === "symbol") {
		listType = expression.list[0].value;
	}

	var out = CURLICUE_KEY.OPEN;

	if (isDialogExpression(listType)) {
		out += serializeWrapped(expression.list, indentDepth);
	}
	else if (isSequence(listType)) {
		out += serializeMulti(expression.list, indentDepth);
	}
	else if (isConditional(listType) || isChoice(listType)) {
		out += serializeAlternating(expression.list, indentDepth);
	}
	else if (isTable(listType)) {
		out += serializePaired(expression.list, indentDepth);
	}
	else if (isFunctionDefinition(listType)) {
		out += serializeMulti(expression.list, indentDepth, 1);
	}
	else {
		out += serializeSingle(expression.list, indentDepth);
	}

	if (out.indexOf("\n") != -1) {
		out += "\n" + (" ".repeat(indentDepth));
	}

	out += CURLICUE_KEY.CLOSE;

	return out;
}

function serializeAtom(value, type) {
	var out = "";

	if (type === "number") {
		out = "" + value;
	}
	else if (type === "string") {
		out = '"' + value + '"';
	}
	else if (type === "boolean") {
		out = value ? "YES" : "NO";
	}
	else if (type === "symbol") {
		out = value;
	}

	return out;
}
this.SerializeValue = serializeAtom;

function serialize(expression, indentDepth) {
	if (indentDepth === undefined || indentDepth === null) {
		indentDepth = 0;
	}

	var out = "";

	if (expression.type === "list") {
		out = serializeList(expression, indentDepth);
	}
	else {
		out = serializeAtom(expression.value, expression.type);
	}

	return out;
}
this.Serialize = serialize;

function serializeFlat(expression) {
	var out = "";

	var tmp = indentStep;
	indentStep = 0;

	if (expression.type === "list") {
		out = serializeList(expression, 0);
	}
	else {
		out = serializeAtom(expression.value, expression.type);
	}

	out = out.replaceAll("\n", " ");

	indentStep = tmp;

	return out;
}
this.SerializeFlat = serializeFlat;

function tokenize(script) {
	// store string literals and replace them with special token
	var stringPattern = /"[\s\S]*?"/g;
	var stringLiterals = script.match(stringPattern);
	script = script.replace(stringPattern, " __string_literal__ ");

	// tokenize on whitespace
	var tokens = script
		.replace(/{/g, " { ")
		.replace(/}/g, " } ")
		.trim()
		.split(/\s+/); // split on whitespace

	// restore string literals
	var stringIndex = 0;
	for (var i = 0; i < tokens.length; i++) {
		if (tokens[i] === "__string_literal__") {
			tokens[i] = stringLiterals[stringIndex];
			stringIndex++;
		}
	}

	return tokens;
}

function parseAtom(token) {
	if (!isNaN(parseFloat(token))) {
		return {
			type: "number",
			value: parseFloat(token),
		};
	}
	else if (token[0] === "\"" && token[token.length - 1] === "\"") {
		return {
			type: "string",
			value: token.substring(1, token.length - 1),
		};
	}
	else if (token === "YES") {
		return {
			type: "boolean",
			value: true,
		};
	}
	else if (token === "NO") {
		return {
			type: "boolean",
			value: false,
		};
	}
	else {
		return {
			type: "symbol",
			value: token,
		};
	}
}
this.ParseValue = function(valueStr) { return parseAtom(valueStr).value; };

function parse(tokens, list) {
	if (list === undefined || list === null) {
		list = [];
	}

	while (tokens.length > 0) {
		var token = tokens.shift();
		if (token === CURLICUE_KEY.OPEN) {
			list.push({
				type: "list",
				list: parse(tokens),
			});
		}
		else if (token === CURLICUE_KEY.CLOSE) {
			break;
		}
		else {
			list.push(parseAtom(token));
		}
	}

	return list;
}

function evalList(expression, environment, onReturn) {
	var i = 0;
	var values = [];
	var evalNext;

	evalNext = function() {
		if (i >= expression.list.length) {
			if (values[0] instanceof Function) {
				values[0](values.slice(1), onReturn);
			}
			else {
				// empty or undefined list
				onReturn(false);
			}
		}
		else {
			eval(expression.list[i], environment, function(value) {
				values.push(value);
				i++;
				evalNext();
			});
		}
	}

	evalNext();
}

function eval(expression, environment, onReturn) {
	if (expression === undefined || environment === undefined || onReturn === undefined) {
		PrintError("invalid expression", onReturn);
	}
	else if (expression.type === "number" || expression.type === "string" || expression.type === "boolean") {
		onReturn(expression.value);
	}
	else if (expression.type === "symbol") {
		onReturn(environment.Get(expression.value));
	}
	else if (expression.type === "list" && expression.list.length > 0 && (expression.list[0].value in special)) {
		special[expression.list[0].value](expression, environment, onReturn);
	}
	else {
		evalList(expression, environment, onReturn);
	}
}

var special = {};

special[CURLICUE_KEY.DIALOG] = function(expression, environment, onReturn) {
	var result = false;
	var i = 1;
	var evalNext;

	// todo : what if no buffer is available?
	var buffer = environment.Get("DIALOG_BUFFER", true);

	function incrementAndEval(value) {
		result = value;
		i++;
		evalNext();
	}

	evalNext = function() {
		if (i >= expression.list.length) {
			onReturn(result);
		}
		else {
			if (expression.list[i].type === "string") {
				if (buffer) {
					buffer.AddText(expression.list[i].value, true /*suppressSpaces*/);
					buffer.AddScriptReturn(function() { incrementAndEval(false); });
				}
				else {
					incrementAndEval(false);
				}
			}
			else if (expression.list[i].type != "list") {
				if (buffer) {
					buffer.AddWord(serializeAtom(expression.list[i].value, expression.list[i].type));
					buffer.AddScriptReturn(function() { incrementAndEval(false); });
				}
				else {
					incrementAndEval(false);
				}
			}
			else {
				eval(expression.list[i], environment, incrementAndEval);
			}
		}
	}

	evalNext();
};

special[CURLICUE_KEY.SEQUENCE] = function(expression, environment, onReturn) {
	if ("index" in expression) {
		expression.index = Math.min(expression.index + 1, expression.list.length - 1);
	}
	else {
		expression.index = 1;
	}

	if (expression.index >= expression.list.length) {
		PrintError("not enough items in SEQ", onReturn);
	}
	else {
		eval(expression.list[expression.index], environment, onReturn);
	}
};

special[CURLICUE_KEY.CYCLE] = function(expression, environment, onReturn) {
	if ("index" in expression) {
		expression.index = Math.max(1, (expression.index + 1) % expression.list.length);
	}
	else {
		expression.index = 1;
	}

	if (expression.index >= expression.list.length) {
		PrintError("not enough items in CYC", onReturn);
	}
	else {
		eval(expression.list[expression.index], environment, onReturn);
	}
};

special[CURLICUE_KEY.SHUFFLE] = function(expression, environment, onReturn) {
	if (("index" in expression) && (expression.index + 1 < expression.shuffle.length)) {
		expression.index++;
	}
	else {
		expression.index = 0;
		expression.shuffle = [];

		var unshuffled = Array(expression.list.length - 1).fill(1).map((x, y) => x + y);
		while (unshuffled.length > 0) {
			var i = Math.floor(Math.random() * unshuffled.length);
			expression.shuffle.push(unshuffled.splice(i, 1)[0]);
		}
	}

	var shuffleIndex = expression.shuffle[expression.index];

	if (shuffleIndex >= expression.list.index) {
		PrintError("not enough items in SHF", onReturn);
	}
	else {
		eval(expression.list[expression.shuffle[expression.index]], environment, onReturn);
	}
};

special[CURLICUE_KEY.CHOICE] = function(expression, environment, onReturn) {
	var i = 1;
	var evalNext;

	var buffer = environment.Get("DIALOG_BUFFER", true);

	// use this to capture the current expression
	function createReturnHandler(expression, environment, onReturn) {
		return function() {
			eval(expression, environment, onReturn);
		}
	}

	evalNext = function() {
		if (i + 1 < expression.list.length) {
			// initialize choice that will evaluate the option result
			var handler = createReturnHandler(expression.list[i + 1], environment, onReturn);

			if (buffer) {
				buffer.AddChoiceOption(handler);
			}

			// eval option (will create the choice text)
			eval(expression.list[i], environment, function() {
				i += 2;
				evalNext();
			});
		}
	};

	if (expression.list.length >= 3) {
		evalNext();
	}
	else {
		PrintError("not enough items in PIK", onReturn);
	}
};

special[CURLICUE_KEY.CONDITIONAL] = function(expression, environment, onReturn) {
	var result = null;
	var i = 1;
	var evalNext;

	evalNext = function() {
		if (i >= expression.list.length) {
			onReturn(false);
		}
		else if (i + 1 >= expression.list.length) {
			eval(expression.list[i], environment, onReturn);
		}
		else {
			eval(expression.list[i], environment, function(value) {
				if (value === true) {
					eval(expression.list[i + 1], environment, onReturn);
				}
				else {
					i += 2;
					evalNext();
				}
			});
		}
	}

	evalNext();
};

special[CURLICUE_KEY.FUNCTION] = function(expression, environment, onReturn) {
	var error = null;

	// initialize parameter names
	var parameterNames = [];
	if (expression.list.length >= 2) {
		if (expression.list[1].type === "list") {
			var parameterList = expression.list[1];
			for (var i = 0; i < parameterList.list.length; i++) {
				if (parameterList.list[i].type === "symbol") {
					parameterNames.push(parameterList.list[i].value);
				}
			}
		}
		else {
			error = "FN input is not list";
		}
	}
	else {
		error = "FN input list is missing";
	}

	var result = function(parameters, onReturn) {
		// create local function environment from input parameters
		var fnEnvironment = new Table(environment); // todo : should it have access to the external environment?
		for (var i = 0; i < parameters.length; i++) {
			if (i < parameterNames.length) {
				fnEnvironment.Set(parameterNames[i], parameters[i]);
			}
		}

		// every expression after the parameter list is a statement in the function
		var result = false;
		var i = 2;
		var evalNext;

		evalNext = function() {
			if (i >= expression.list.length) {
				onReturn(result);
			}
			else {
				eval(expression.list[i], fnEnvironment, function(value) {
					result = value;
					i++;
					evalNext();
				});
			}
		}

		evalNext();
	};

	if (error === null && expression.list.length < 3) {
		error = "FN body is empty";
	}

	if (error != null) {
		PrintError(error, onReturn);
	}
	else {
		onReturn(result);
	}
};

// local variable
special[CURLICUE_KEY.VARIABLE] = function(expression, environment, onReturn) {
	function setValue(value) {
		environment.SetLocal(expression.list[1].value, value);
		onReturn(value);
	}

	if (expression.list.length < 2 || expression.list[1].type != "symbol") {
		PrintError("VAR symbol is missing", onReturn);
	}
	else if (expression.list.length < 3) {
		// no value provided - set to false
		setValue(false);
	}
	else {
		eval(expression.list[2], environment, setValue);
	}
};

// global variable / variable assignment
special[CURLICUE_KEY.ASSIGN] = function(expression, environment, onReturn) {
	function setValue(value) {
		environment.SetGlobal(expression.list[1].value, value);
		onReturn(value);
	}

	if (expression.list.length < 2 || expression.list[1].type != "symbol") {
		PrintError("SET symbol is missing", onReturn);
	}
	else if (expression.list.length < 3) {
		// no value provided - set to false
		setValue(false);
	}
	else {
		eval(expression.list[2], environment, setValue);
	}
};

special[CURLICUE_KEY.TABLE] = function(expression, environment, onReturn) {
	var table = new Table();
	var i = 1;
	var evalNext;

	evalNext = function() {
		if (i >= expression.list.length) {
			onReturn(table);
		}
		else {
			if (expression.list[i].type === "symbol" && expression.list[i].value[0] === CURLICUE_KEY.ENTRY) {
				var name = expression.list[i].value.slice(1);
				i++;

				if (i >= expression.list.length) {
					PrintError("TBL entry value is missing", onReturn);
				}
				else {
					eval(expression.list[i], environment, function(value) {
						table.Set(name, value);
						i++;
						evalNext();
					});
				}
			}
			else {
				// for now, skip invalid syntax
				// TODO : decide whether to allow a lua-like "list" form
				PrintError("TBL entry name is missing", onReturn);
			}
		}
	}

	evalNext();
};

special[CURLICUE_KEY.ENTRY] = function(expression, environment, onReturn) {
	if (expression.list.length < 2) {
		PrintError("no TBL to get entry from", onReturn);
	}
	else if (expression.list.length < 3 || expression.list[2].type != "symbol") {
		PrintError("entry name is missing", onReturn);
	}
	else {
		var key = expression.list[2].value;

		eval(expression.list[1], environment, function(table) {
			if (!IsATable(table)) {
				PrintError("expected a TBL", onReturn);
			}
			else if (expression.list.length >= 4) {
				eval(expression.list[3], environment, function(value) {
					table.Set(key, value);
					onReturn(value);
				});
			}
			else if (table.Has(key)) {
				onReturn(table.Get(key));
			}
			else {
				onReturn(false); // no value!
			}
		});
	}
};

} // CurlicueScript

function Table(parent) {
	this["_is_table_"] = true;

	var entries = {};
	var keyList = []; // maintained in insertion order
	var readOnlyEntries = {}; // todo : is this the best way to keep track of this?

	var hasParent = parent != undefined && parent != null;

	var GetInternalKey = function(key, isSecret) {
		return isSecret ? key : CURLICUE_KEY.ENTRY + key;
	}

	function hasInternalKey(internalKey) {
		return entries.hasOwnProperty(internalKey) &&
			entries[internalKey] != null && entries[internalKey] != undefined;
	}

	this.Has = function(key, isSecret) {
		var hasEntry = false;
		var internalKey = GetInternalKey(key, isSecret);

		if (hasInternalKey(internalKey)) {
			hasEntry = true;
		}
		else if (hasParent && parent.Has(key, isSecret)) {
			hasEntry = true;
		}

		return hasEntry;
	};

	this.Get = function(key, isSecret) {
		var value = false;
		var internalKey = GetInternalKey(key, isSecret);

		if (hasInternalKey(internalKey)) {
			value = entries[internalKey];
		}
		else if (hasParent && parent.Has(key, isSecret)) {
			value = parent.Get(key, isSecret);
		}

		return value;
	};

	function set(key, value, options) {
		var isLocal = options && options.isLocal;
		var isGlobal = options && options.isGlobal;
		var isSecret = options && options.isSecret;
		var isReadOnly = options && options.isReadOnly;
		var externalKey = options && options.externalKey ? options.externalKey : null;

		var internalKey = GetInternalKey(key, isSecret);
		var hasInternalEntry = hasInternalKey(internalKey);

		if (!isLocal && (!hasInternalEntry || readOnlyEntries[internalKey]) && hasParent && (isGlobal || parent.Has(key, isSecret))) {
			parent.Set(key, value, options);
		}
		else if (!readOnlyEntries[internalKey]) {
			if (!hasInternalEntry) {
				if (!isSecret) {
					keyList.push(key);
				}

				if (isReadOnly) {
					readOnlyEntries[internalKey] = true;
				}

				AddGetterSetter(externalKey != null ? externalKey : key, internalKey);
			}

			entries[internalKey] = value;
		}

		return value;
	}

	this.Set = set;

	// todo : clean up these APIs?
	this.SetLocal = function(key, value) {
		set(key, value, { isLocal: true });
	};

	this.SetGlobal = function(key, value) {
		set(key, value, { isGlobal: true });
	};

	this.SetSecret = function(key, value) {
		set(key, value, { isSecret: true });
	};

	// only includes keys for entries that are not secret
	this.Keys = function() {
		return keyList;
	};

	// adds external getter and setter for convenience of the engine
	var AddGetterSetter = (function(table) {
		return function(externalKey, internalKey) {
			var getterSetter = {};

			getterSetter[externalKey] = {
				get : function() {
					return entries[internalKey];
				},
				set : function(value) {
					entries[internalKey] = value;
				},
			};

			Object.defineProperties(table, getterSetter);
		};
	})(this);
} // Table

function PrintError(message, onReturn) {
	message = DEBUG_KEY.ERROR + ": " + message;
	console.log(message);

	if (isPlayerEmbeddedInEditor && dialogBuffer) {
		dialogBuffer.AddTextEffect("_debug_error");
		dialogBuffer.AddText(message);
		dialogBuffer.RemoveTextEffect("_debug_error");
		dialogBuffer.AddScriptReturn(function() { onReturn(false); });
	}
	else if (onReturn) {
		onReturn(false);
	}
}

function IsATable(x) {
	return x != undefined && x != null && (typeof(x) === "object") && x["_is_table_"];
}
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		textureId : null,
		width : 8 + 96, // 8 for left-right padding, 96 for text
		height : 8 + 4 + 2 + 6, //8 for text, 4 for top-bottom padding, 2 for line padding, 6 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 6,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.textureId = bitsyTextureCreate(textboxInfo.width * scale, textboxInfo.height * scale);
	}

	function relativeFontWidth() {
		return Math.ceil(font.getWidth() * (text_scale / scale));
	}

	function relativeFontHeight() {
		return Math.ceil(font.getHeight() * (text_scale / scale));
	}

	this.ClearTextbox = function() {
		//create new image none exists
		if (textboxInfo.textureId == null) {
			textboxInfo.textureId = bitsyTextureCreate(textboxInfo.width * scale, textboxInfo.height * scale);
		}

		// fill text box with background color
		var colorIndex = color.GetColorIndex(COLOR_INDEX.TEXTBOX);
		bitsyTextureFill(textboxInfo.textureId, colorIndex);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if (isCentered) {
			bitsyCanvasPutTexture(
				textboxInfo.textureId,
				textboxInfo.left * scale,
				((height / 2) - (textboxInfo.height / 2)) * scale);
		}
		else if (player().y < roomsize/2) {
			//bottom
			bitsyCanvasPutTexture(
				textboxInfo.textureId,
				textboxInfo.left * scale,
				(height - textboxInfo.bottom - textboxInfo.height) * scale);
		}
		else {
			//top
			bitsyCanvasPutTexture(
				textboxInfo.textureId,
				textboxInfo.left * scale,
				textboxInfo.top * scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		drawArrow(arrowdata, textDirection === TEXT_DIRECTION_KEY.RIGHT_TO_LEFT);
	};

	var choiceArrowLeft = [
		0,1,0,0,0,
		1,1,0,0,0,
		0,1,0,0,0,
	];

	var choiceArrowRight = [
		0,0,0,1,0,
		0,0,0,1,1,
		0,0,0,1,0,
	];

	var choiceDot = [
		0,0,0,0,0,
		0,0,1,0,0,
		0,0,0,0,0,
	];

	var choiceDotSelected = [
		0,0,1,0,0,
		0,1,1,1,0,
		0,0,1,0,0,
	];

	this.DrawChoiceSelect = function(choiceIndex, choiceCount, areArrowsVisible) {
		if (areArrowsVisible) {
			drawArrow(choiceArrowLeft, true);
			drawArrow(choiceArrowRight, false);
		}

		var top = (textboxInfo.height - 4);
		var left = (textboxInfo.width / 2) - Math.floor((choiceCount * 5) / 2);
		for (var i = 0; i < choiceCount; i++) {
			drawTextboxIcon(i === choiceIndex ? choiceDotSelected : choiceDot, top, left);
			left += 5;
		}
	}

	function drawArrow(arrowImgData, isLeftSide) {
		var top = (textboxInfo.height - 4);
		var left = isLeftSide ? (4) : (textboxInfo.width - (5 + 4));
		drawTextboxIcon(arrowImgData, top, left);
	}

	function drawTextboxIcon(imgData, top, left) {
		var colorIndex = color.GetColorIndex(COLOR_INDEX.TEXT);
		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (imgData[i] == 1) {
					bitsyTextureSetPixel(textboxInfo.textureId, left + x, top + y, scale, colorIndex);
				}
			}
		}
	}

	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var textToRoomScaleRatio = scale / text_scale; 

		var top = (4 * textToRoomScaleRatio) + (row * 2 * textToRoomScaleRatio) + (row * font.getHeight()) + Math.floor(char.offset.y);
		var left = (4 * textToRoomScaleRatio) + (leftPos) + Math.floor(char.offset.x);

		var debug_r = Math.random() * 255;

		var colorIndex = color.GetColorIndex(char.color);

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {
				var i = (y * char.width) + x;
				if (charData[i] == 1 && !bitsyPaletteIsTransparent(colorIndex)) {
					bitsyTextureSetPixel(textboxInfo.textureId, left + x, top + y, text_scale, colorIndex);
				}
			}
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer, dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.IsChoicePage()) {
			this.DrawChoiceSelect(buffer.CurChoiceIndex(), buffer.CurChoiceCount(), buffer.CanContinue());
		}
		else if (buffer.CanContinue()) {
			this.DrawNextArrow();
		}

		this.DrawTextbox();
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = []; // holds dialog in an array buffer

	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;

	var choiceIndex = 0;

	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds

	var activeTextEffects = [];

	var font = null;
	var arabicHandler = new ArabicHandler();

	var onDialogEndCallbacks = [];

	// TODO : these seem like good reasons to combine the buffer and the renderer
	var maxRowCount = 2;
	var pixelsPerRow = 96 * (scale / text_scale); // (slightly less) hard-coded fun times!!!

	function AddPage() {
		var page = {
			rows : [],
			isFinished : false,
			postPageScriptHandlers : [],
		};

		buffer.push(page);

		AddRow();
	}

	function AddRow() {
		var row = {
			chars : [],
			isFinished : false,
		};

		LastPage().rows.push(row);
	}

	function AddChoice() {
		var choice = {
			isChoice : true,
			pages : [],
		};

		buffer.push(choice);
	}

	this.AddChoiceOption = function(onReturnHandler) {
		if (!IsLastPageChoice() || LastPage().isFinished) {
			AddChoice();
		}

		var page = {
			rows : [],
			isFinished : false,
			postPageScriptHandlers : [],
		};

		var controlChar = new DialogScriptControlChar();
		controlChar.SetHandler(function() {
			console.log("CHOICE -- RETURN TO SCRIPT EXECUTION!");
			LastPage().isFinished = true; // todo : any chance of bugs with this?
			onReturnHandler();
		});

		page.postPageScriptHandlers.push(controlChar);

		buffer[buffer.length - 1].pages.push(page);

		AddRow();
	}

	this.SetFont = function(f) {
		font = f;
	}

	function CurPage() {
		if (IsChoicePage()) {
			return buffer[pageIndex].pages[choiceIndex];
		}
		else {
			return buffer[pageIndex];
		}
	};

	function CurRow() {
		return CurPage().rows[rowIndex];
	};

	function CurChar() {
		if (CurRow() == null) {
			return null;
		}

		return CurRow().chars[charIndex];
	}

	function CurPageCount() {
		return buffer.length;
	};

	function CurRowCount() {
		return CurPage().rows.length;
	}

	function CurCharCount() {
		if (CurRow() == null) {
			return -1;
		}

		return CurRow().chars.length;
	}

	function IsLastPageChoice() {
		return buffer.length > 0 && ("isChoice" in buffer[buffer.length - 1]) && buffer[buffer.length - 1].isChoice;
	}

	function LastPage() {
		if (IsLastPageChoice()) {
			var choicePage = buffer[buffer.length - 1];
			return choicePage.pages[choicePage.pages.length - 1];
		}
		else {
			return buffer[buffer.length - 1];
		}
	}

	function LastRow() {
		var rows = LastPage().rows;
		return rows[rows.length - 1];
	}

	// Iterates over visible characters on the active page
	this.ForEachActiveChar = function(handler) {
		var rowArray = CurPage().rows;

		for (var i = 0; i < Math.min(rowIndex + 1, rowArray.length); i++) {
			var row = rowArray[i];

			var charCount = (i == rowIndex) ? (charIndex + 1) : row.chars.length;

			var leftPos = 0;
			if (textDirection === TEXT_DIRECTION_KEY.RIGHT_TO_LEFT) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for (var j = 0; j < charCount; j++) {
				var char = row.chars[j];
				if (char) {
					if (textDirection === TEXT_DIRECTION_KEY.RIGHT_TO_LEFT) {
						leftPos -= char.spacing;
					}

					handler(char, i, /*rowIndex*/ j, /*colIndex*/ leftPos);

					if (textDirection === TEXT_DIRECTION_KEY.LEFT_TO_RIGHT) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [];
		pageIndex = 0;
		choiceIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		activeTextEffects = [];
		onDialogEndCallbacks = [];
		isNextSpaceSuppressed = false;
	};

	function DoNextChar() {
		nextCharTimer = 0; // reset timer

		// first, if this is an inline script control char,
		// make sure to execute the next part of the script
		if (CurChar() != null && CurChar().isScriptControlChar) {
			CurChar().ContinueScriptExecution();
			nextCharTimer = nextCharMaxTime; // forces us to continue immediately to next char
		}

		// then update the current character location
		if (charIndex < CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex < CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
	};

	this.Update = function(dt) {
		nextCharTimer += dt; // tick timer

		while (nextCharTimer >= nextCharMaxTime && !this.CanContinue()) {
			DoNextChar();
		}
	};

	this.Skip = function() {
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < CurRowCount()) {
			DoNextChar();

			if (this.CanContinue()) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
	};

	this.Continue = function() {
		// todo... should these use callbacks? is it really possible to have more than one?
		for (var i = 0; i < CurPage().postPageScriptHandlers.length; i++) {
			CurPage().postPageScriptHandlers[i].ContinueScriptExecution();
		}

		pageIndex++;

		if (pageIndex < CurPageCount()) {
			// flip page!
			rowIndex = 0;
			charIndex = 0;
			nextCharTimer = 0;
			choiceIndex = 0;
		}
		else {
			// end of dialog
			for (var i = 0; i < onDialogEndCallbacks.length; i++) {
				onDialogEndCallbacks[i]();
			}
		}

		return IsActive(); // hasMoreDialog
	};

	this.NextChoice = function() {
		if (IsChoicePage()) {
			choiceIndex++;

			if (choiceIndex >= buffer[pageIndex].pages.length) {
				choiceIndex = 0;
			}

			rowIndex = 0;
			charIndex = 0;
			nextCharTimer = 0;
		}
	}

	this.PrevChoice = function() {
		if (IsChoicePage()) {
			choiceIndex--;

			if (choiceIndex < 0) {
				choiceIndex = buffer[pageIndex].pages.length - 1;
			}

			rowIndex = 0;
			charIndex = 0;
			nextCharTimer = 0;
		}
	}

	function IsActive() {
		return pageIndex < CurPageCount();
	}
	this.IsActive = IsActive;

	this.OnDialogEnd = function(callback) {
		if (!IsActive()) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	function IsChoicePage() {
		return IsActive() && ("isChoice" in buffer[pageIndex]) && buffer[pageIndex].isChoice;
	};
	this.IsChoicePage = IsChoicePage;

	this.CurChoiceIndex = function() {
		return choiceIndex;
	}

	this.CurChoiceCount = function() {
		return IsChoicePage() ? buffer[pageIndex].pages.length : 0;
	}

	this.CanContinue = function() {
		return charIndex >= CurCharCount() && rowIndex >= CurRowCount();
	};

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = COLOR_INDEX.TEXT;
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i].name;
				// console.log("FX " + effectName);
				TextEffects[effectName].DoEffect(this, time, this.effectList[i].parameters);
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetTileSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isScriptControlChar = true;

		var handlerFunc = null;

		this.SetHandler = function(handler) {
			handlerFunc = handler;
		}

		this.ContinueScriptExecution = function() {
			if (handlerFunc != null) {
				handlerFunc();
			}
		}
	}

	function CreateCharArray(word, effectList) {
		var charArray = [];

		for (var i = 0; i < word.length; i++) {
			charArray.push(new DialogFontChar(font, word[i], effectList));
		}

		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	this.AddScriptReturn = function(onReturnHandler) {
		if (IsLastPageChoice()) {
			onReturnHandler(); // return immediately to create choice options!
		}
		else {
			var controlChar = new DialogScriptControlChar();
			controlChar.SetHandler(function() {
				console.log("RETURN TO SCRIPT EXECUTION!");
				onReturnHandler();
			});

			if (IsActive() && LastPage().isFinished) {
				console.log("ADD SCRIPT RETURN -- post page");
				// add script return after page ends
				LastPage().postPageScriptHandlers.push(controlChar);
			}
			else if (IsActive()) {
				console.log("ADD SCRIPT RETURN -- inline");
				console.log(LastPage());
				// add inline script return
				LastRow().chars.push(controlChar);
			}
			else {
				// TODO
				console.log("OH NO NOTHING IS ACTIVE!!!");
			}
		}
	}

	function AddWordCharArray(wordCharArray, prependSpaceChar) {
		if (prependSpaceChar === undefined || prependSpaceChar === null) {
			prependSpaceChar = false;
		}

		var spaceCharArray = CreateCharArray(" ", activeTextEffects);

		// figure out if the word fits on the current row
		var wordLength = prependSpaceChar ?
			GetCharArrayWidth(spaceCharArray.concat(wordCharArray)) : GetCharArrayWidth(wordCharArray);
		var rowLength = IsActive() ? GetCharArrayWidth(LastRow().chars) : 0;
		var doesWordFitOnRow = rowLength + wordLength <= pixelsPerRow || rowLength <= 0;

		// mark whether the current row and/or page will now be finished
		if (IsActive()) {
			LastRow().isFinished = LastRow().isFinished || !doesWordFitOnRow;

			var finalRowFinished = (LastRow().isFinished && LastPage().rows.length + 1 > maxRowCount);
			LastPage().isFinished = LastPage().isFinished || finalRowFinished;
		}

		// do we need to start a new page or row?
		var isNewLine = !IsActive() || LastRow().isFinished;
		var isNewPage = !IsActive() || LastPage().isFinished;

		// add the word
		if (isNewPage) {
			//start next page
			AddPage();
			LastRow().chars = LastRow().chars.concat(wordCharArray);
		}
		else if (isNewLine) {
			//start next row
			AddRow();
			LastRow().chars = LastRow().chars.concat(wordCharArray);
		}
		else {
			//stay on same row
			wordCharArray = prependSpaceChar ? spaceCharArray.concat(wordCharArray) : wordCharArray;
			LastRow().chars = LastRow().chars.concat(wordCharArray);
		}
	}

	var isNextSpaceSuppressed = false;

	this.AddDrawing = function(drawingId) {
		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects);
		AddWordCharArray([drawingChar], !isNextSpaceSuppressed);

		isNextSpaceSuppressed = false;
	}

	this.AddText = function(textStr, suppressWhitespace) {
		if (suppressWhitespace === undefined ||suppressWhitespace === null) {
			suppressWhitespace = false;
		}

		// add text to page buffer, one line and word at a time
		var lines = textStr.split("\n");

		for (var i = 0; i < lines.length; i++) {
			if (i > 0) {
				AddLinebreak();
			}

			var words = lines[i].split(" ");

			for (var j = 0; j < words.length; j++) {
				var word = words[j];

				if (arabicHandler.ContainsArabicCharacters(word)) {
					word = arabicHandler.ShapeArabicCharacters(word);
				}

				var wordCharArray = CreateCharArray(word, activeTextEffects);
				var prependSpaceChar = i > 0 || j > 0 || (!suppressWhitespace && !isNextSpaceSuppressed);

				AddWordCharArray(wordCharArray, prependSpaceChar);
			}
		}

		isNextSpaceSuppressed = suppressWhitespace;
	};

	// todo... share stuff with AddText?
	this.AddWord = function(wordStr) {
		if (arabicHandler.ContainsArabicCharacters(wordStr)) {
			wordStr = arabicHandler.ShapeArabicCharacters(wordStr);
		}

		var wordCharArray = CreateCharArray(wordStr, activeTextEffects);

		AddWordCharArray(wordCharArray, !isNextSpaceSuppressed);

		isNextSpaceSuppressed = false;
	}

	function AddLinebreak() {
		// TODO : decide if this is the right behavior
		// // Ensure there is a row to mark as finished
		if (!IsActive() || LastPage().rows.length + 1 > maxRowCount) {
			// todo : mark last page finished
			AddPage();
		}
		else if (IsActive() && LastRow().isFinished) {
			AddRow();
		}
		else if (IsActive()) {
			LastRow().isFinished = true;
		}
	}
	this.AddLinebreak = AddLinebreak;

	this.AddPagebreak = function() {
		// TODO : decide if this is the right behavior
		// Ensure there is a page to mark as finished
		if (!IsActive() || LastPage().isFinished) {
			AddPage();
		}
		else if (IsActive()) {
			LastPage().isFinished = true;
		}
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		var findFirstWithName = function (effect) {
			return effect.name === name;
		};

		return activeTextEffects.findIndex(findFirstWithName) > -1;
	}

	this.AddTextEffect = function(name, parameters) {
		activeTextEffects.push({
			name: name,
			parameters: parameters,
		});
	}

	this.RemoveTextEffect = function(name) {
		var findFirstWithName = function (effect) {
			return effect.name === name;
		};

		var index = activeTextEffects.slice().reverse().findIndex(findFirstWithName);

		if (index > -1) {
			index = (activeTextEffects.length - 1) - index;
			activeTextEffects.splice(index, 1);
		}
	}
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() {
	this.DoEffect = function(char, time) {
		var startIndex = COLOR_INDEX.RAINBOW_START;
		var len = (COLOR_INDEX.RAINBOW_END - COLOR_INDEX.RAINBOW_START) + 1;
		char.color = startIndex + (char.col % len);
	}
};
TextEffects["RBW"] = new RainbowEffect();

var ColorEffect = function() {
	this.DoEffect = function(char, time, parameters) {
		var index = parameters[0];
		char.color = COLOR_INDEX.BACKGROUND + index;
	}
};
TextEffects["CLR"] = new ColorEffect();

var WavyEffect = function() {
	this.DoEffect = function(char, time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * (2 * (scale / text_scale));
	}
};
TextEffects["WVY"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func, time, offset, mult1, mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char, time) {
		char.offset.y += (1.5 * (scale / text_scale))
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += (1.5 * (scale / text_scale))
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	}
};
TextEffects["SHK"] = new ShakyEffect();

var DebugErrorEffect = function() {
	this.DoEffect = function(char) {
		char.color = COLOR_INDEX.RAINBOW_START;
		char.offset.x = 0;
		char.offset.y = 0;
	}
}
TextEffects["_debug_error"] = new DebugErrorEffect();

} // Dialog()
</script>

<script>
function Renderer(roomsize, tilesize, scale) {

var cache = {
	source: {},
	render: {},
};

var debugRenderCount = 0;

function renderTileFrame(drawing, frameOverride) {
	var frameIndex = getFrameIndex(drawing, frameOverride);
	var frameSource = cache.source[drawing.drw][frameIndex];
	var backgroundIndex = drawing.colorOffset + drawing.bgc;
	var colorIndex = drawing.colorOffset + drawing.col;
	return createTextureFromTileSource(frameSource, backgroundIndex, colorIndex);
}

function createTextureFromTileSource(tileSource, bgcIndex, colIndex) {
	var textureId = bitsyTextureCreate(tilesize * scale, tilesize * scale);

	var foregroundColorIndex = color.GetColorIndex(colIndex);
	var backgroundColorIndex = color.GetColorIndex(bgcIndex);
	if (bitsyPaletteIsTransparent(foregroundColorIndex)) {
		foregroundColorIndex = backgroundColorIndex;
	}

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = tileSource[y][x];
			var colorIndex = (px === 1) ? foregroundColorIndex : backgroundColorIndex;

			if (colorIndex < 0 || colorIndex >= color.RoomPaletteSize()) {
				colorIndex = COLOR_INDEX.BACKGROUND;
			}

			bitsyTextureSetPixel(textureId, x, y, scale, colorIndex);
		}
	}

	bitsyTextureCommit(textureId);

	return textureId;
}

function getCacheId(drawingId, frameIndex, backgroundIndex, colorIndex) {
	return "drw" + drawingId + "_f" + frameIndex + "_b" + backgroundIndex + "_c" + colorIndex;
}

function getFrameIndex(drawing, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return frameIndex;
}

function getCacheIdFromDrawing(drawing, frameOverride) {
	var frameIndex = getFrameIndex(drawing, frameOverride);
	var backgroundIndex = color.GetColorIndex(drawing.colorOffset + drawing.bgc);
	var colorIndex = color.GetColorIndex(drawing.colorOffset + drawing.col);

	return getCacheId(drawing.drw, frameIndex, backgroundIndex, colorIndex);
}

function getOrRenderTile(drawing, frameOverride) {
	var renderCacheId = getCacheIdFromDrawing(drawing, frameOverride);

	if (!(renderCacheId in cache.render)) {
		cache.render[renderCacheId] = renderTileFrame(drawing, frameOverride);
	}

	return cache.render[renderCacheId];
}

function resetAllTextures() {
	for (var id in cache.render) {
		var textureId = cache.render[id];
		bitsyTextureRelease(textureId);

		delete cache.render[id];
	}
}

/* PUBLIC INTERFACE */
this.GetRenderedTile = getOrRenderTile;

this.SetTileSource = function(drawingId, sourceData) {
	cache.source[drawingId] = sourceData;

	// render cache is now out of date!
	resetAllTextures(); // todo : will this cause problems?
}

this.GetTileSource = function(drawingId) {
	return cache.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return cache.source[drawingId].length;
}

this.ResetRenderCache = function() {
	resetAllTextures();
}

// with this here can I simplify the sprite instance?
function CreateDrawingDataFromSpriteInstance(sprite) {
	return {
		drw: sprite.drw,
		col: sprite.col,
		bgc: sprite.bgc,
		colorOffset: sprite.colorOffset,
		animation: tile[sprite.drw].animation, // currently animation state is global
	};
}

function ScreenRenderTarget() {
	var width = roomsize * tilesize * scale;
	var height = roomsize * tilesize * scale;
	var tileIncrement = tilesize * scale;

	this.Clear = function() {
		bitsyCanvasClear(COLOR_INDEX.BACKGROUND);
	};

	function Draw(drawing, x, y, options) {
		var frameOverride = options && options.frameIndex ? options.frameIndex : null;

		if (drawing.drw in tile) {
			var renderedTile = getOrRenderTile(drawing, frameOverride);
			bitsyCanvasPutTexture(renderedTile, x * tileIncrement, y * tileIncrement);
		}
		else {
			console.log("TRYING TO DRAW MISSING TILE " + drawing.drw);
		}
	}

	this.DrawTile = function(tileId, x, y, options) {
		Draw(tile[tileId], x, y, options);
	};

	this.DrawSprite = function(sprite, x, y, options) {
		if (sprite === undefined || !(sprite.id in tile)) {
			console.log("TRYING TO DRAW MISSING SPRITE!");
			return;
		}

		// todo : do I need the x and y passed in?
		Draw(CreateDrawingDataFromSpriteInstance(sprite), x, y, options);
	};
}

this.CreateScreenTarget = function() {
	return new ScreenRenderTarget();
};

function PaletteIndexBufferRenderTarget() {
	var width = roomsize * tilesize;
	var height = roomsize * tilesize;

	var pixelData = new Array(width * height);

	this.Clear = function() {
		pixelData.fill(COLOR_INDEX.BACKGROUND, 0, width * height);
	};

	function Draw(drawing, x, y, options) {
		var frameOverride = options && options.frameIndex ? options.frameIndex : null;
		var frameIndex = getFrameIndex(drawing, frameOverride);
		var frameData = cache.source[drawing.drw][frameIndex];

		var backgroundIndex = color.GetColorIndex(drawing.colorOffset + drawing.bgc);
		var foregroundIndex = color.GetColorIndex(drawing.colorOffset + drawing.col);

		var top = y * tilesize;
		var left = x * tilesize;

		for (var dy = 0; dy < tilesize; dy++) {
			for (var dx = 0; dx < tilesize; dx++) {
				// todo : catch index out of bounds?
				var pixelIndex = (width * (top + dy)) + (left + dx);

				if (frameData[dy][dx] === 1 && foregroundIndex != COLOR_INDEX.TRANSPARENT) {
					pixelData[pixelIndex] = foregroundIndex;
				}
				else if (backgroundIndex != COLOR_INDEX.TRANSPARENT) {
					pixelData[pixelIndex] = backgroundIndex;
				}
			}
		}
	}

	this.DrawTile = function(tileId, x, y, options) {
		Draw(tile[tileId], x, y, options);
	};

	this.DrawSprite = function(sprite, x, y, options) {
		Draw(CreateDrawingDataFromSpriteInstance(sprite), x, y, options);
	};

	this.Width = width;
	this.Height = height;

	this.GetPixel = function(x, y) {
		return pixelData[(y * width) + x];
	};
}

this.CreateBufferTarget = function() {
	return new PaletteIndexBufferRenderTarget();
};

function TilemapBufferRenderTarget() {
	var width = roomsize;
	var height = roomsize;

	var tilemapData = [];

	this.Clear = function() {
		for (var i = 0; i < width * height; i++) {
			tilemapData.push({ drw: "0", col: 0, bgc: 0, });
		}
	};

	function Draw(drawing, x, y, options) {
		tilemapData[(parseInt(y) * width) + parseInt(x)] = {
			drw: drawing.drw,
			col: drawing.col,
			bgc: drawing.bgc,
		};
	}

	this.DrawTile = function(tileId, x, y, options) {
		Draw(tile[tileId], x, y, options);
	};

	this.DrawSprite = function(sprite, x, y, options) {
		Draw(sprite, x, y, options);
	};

	this.Width = width;
	this.Height = height;

	this.GetTile = function(x, y) {
		return tilemapData[(y * width) + x];
	};
}

this.CreateTileBufferTarget = function() {
	return new TilemapBufferRenderTarget();
};

} // Renderer()
</script>

<script>
// World Data
var map = {};
var room = {};
var tile = {};
var dialog = {};
var palette = {};
var variable = {}; // todo : fix bugs now that these are actually used during the game..

// Game State
var playerId = null;
var tilemap = [];
var spriteInstances = {};
var instanceCount = 1;
var playerInstanceId = "1"; // todo : is this ok hardcoded?

// title
var titleId = NULL_ID;

function getTitle() {
	return dialog[titleId].src;
}

function setTitle(titleSrc) {
	dialog[titleId].src = titleSrc;
}

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var textDirection = TEXT_DIRECTION_KEY.LEFT_TO_RIGHT;

/* VERSION */
var version = {
	major: 8, // major changes
	minor: 0, // smaller changes
	devBuildPhase: "BETA",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0, // 0 = non-comma separated, 1 = comma separated
		PAL_FORMAT : 0, // 0 = rgb comma separated, 1 = hex
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	map = {};
	room = {};
	item = {};
	tile = {};
	dialog = {};
	palette = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	// hacky to have this multiple times...
	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map(),
		dialog : new Map(),
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TEXT_DIRECTION_KEY.LEFT_TO_RIGHT;
}

var curRoom = null;

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;

var isPlayerEmbeddedInEditor = false;

var parser = new Parser();
var renderer = new Renderer(roomsize, tilesize, scale);

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.Reset();

	renderer.ResetRenderCache();

	parser.ParseWorld(game_data);

	var instance = createAvatarInstance("1");
	if (instance != null) {
		spriteInstances["1"] = instance;
	}

	// set the first room
	var roomIds = Object.keys(room);
	if (player() != null && player().room != null && roomIds.includes(player().room)) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	// initialize the first room
	if (curRoom != null) {
		initRoom(curRoom);
	}

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	// setInterval(updateLoadingScreen, 300); // hack test

	colorCycleCounter = 0;
	animationCounter = 0;

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

var update_interval = null;
function onready(startWithTitle) {
	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart, {passive:false});
		canvas.addEventListener('touchmove', input.ontouchmove, {passive:false});
		canvas.addEventListener('touchend', input.ontouchend, {passive:false});
	}
	else {
		// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

		// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
	  	var existingTouchTrigger = document.querySelector('#touchTrigger');
	  	if (existingTouchTrigger === null){
	  	  var touchTrigger = document.createElement("div");
	  	  touchTrigger.setAttribute("id","touchTrigger");

	  	  // afaik css in js is necessary here to force a fullscreen element
	  	  touchTrigger.setAttribute(
	  	    "style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
	  	  );
	  	  document.body.appendChild(touchTrigger);

	  	  touchTrigger.addEventListener('touchstart', input.ontouchstart);
	  	  touchTrigger.addEventListener('touchmove', input.ontouchmove);
	  	  touchTrigger.addEventListener('touchend', input.ontouchend);
	  	}
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update, 16);

	if (startWithTitle) { // used by editor 
		startTitle();
	}
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		// check for touchTrigger and removes it
		var existingTouchTrigger = document.querySelector('#touchTrigger');
		if (existingTouchTrigger !== null){
			existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
			existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
			existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

			existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
		}
	}

	window.onblur = null;

	clearInterval(update_interval);

	dialogBuffer.Reset();
	scriptInterpreter.Reset();
	renderer.ResetRenderCache();
	transition.Cancel();
	isNarrating = false;
	isEnding = false;
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null && !dialogBuffer.IsActive()) {
		// in the special case where there is no valid room, end the game
		isEnding = true;
	}

	updateRender();

	updateInput();

	updateCuedScripts();

	prevTime = curTime;

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateRender(renderOptions) {
	if (transition.IsTransitionActive()) {
		// transitions take over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		updateColorCycle();

		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom(room[curRoom], renderOptions);
		}
		else {
			// for title and ending just clear the screen!
			bitsyCanvasClear(COLOR_INDEX.BACKGROUND);
		}

		if (dialogBuffer.IsActive()) {
			dialogRenderer.Draw(dialogBuffer, deltaTime);
			dialogBuffer.Update(deltaTime);
		}
	}
}

function renderOnlyUpdate(renderOptions) {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	updateRender(renderOptions);

	prevTime = curTime;
}

function updateInput() {
	if (transition.IsTransitionActive()) {
		// do nothing
	}
	else if (dialogBuffer.IsActive()) {
		// todo : can choice and non-choice input share anything?
		if (dialogBuffer.IsChoicePage()) {
			if (dialogBuffer.CanContinue()) {
				if (input.isKeyDown(key.left) || input.isKeyDown(key.a) || input.swipeLeft()
					|| input.isKeyDown(key.up) || input.isKeyDown(key.w) || input.swipeUp()) {
					dialogBuffer.PrevChoice();
				}
				else if (input.isKeyDown(key.right) || input.isKeyDown(key.d) || input.swipeRight()
					|| input.isKeyDown(key.down) || input.isKeyDown(key.s) || input.swipeDown()) {
					dialogBuffer.NextChoice();
				}
				else if (input.isKeyDown(key.enter) || input.isKeyDown(key.space) || input.isTapReleased()) {
					// select choice!
					dialogBuffer.Continue();
				}
				input.ignoreHeldKeys(); // I think we want to do this for all choice input?
			}
			else {
				if (input.anyKeyPressed() || input.isTapReleased()) {
					dialogBuffer.Skip();
					input.ignoreHeldKeys();
				}
			}
		}
		else {
			if (input.anyKeyPressed() || input.isTapReleased()) {
				/* CONTINUE DIALOG */
				if (dialogBuffer.CanContinue()) {
					var hasMoreDialog = dialogBuffer.Continue();
					if (!hasMoreDialog) {
						// ignore currently held keys UNTIL they are released (stops player from insta-moving)
						input.ignoreHeldKeys();
					}
				}
				else {
					dialogBuffer.Skip();
				}
			}
		}
	}
	else if (isEnding) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (input.isKeyDown(key.left) || input.isKeyDown(key.a) || input.swipeLeft()) {
			curPlayerDirection = BUTTON_KEY.LEFT;
		}
		else if (input.isKeyDown(key.right) || input.isKeyDown(key.d) || input.swipeRight()) {
			curPlayerDirection = BUTTON_KEY.RIGHT;
		}
		else if (input.isKeyDown(key.up) || input.isKeyDown(key.w) || input.swipeUp()) {
			curPlayerDirection = BUTTON_KEY.UP;
		}
		else if (input.isKeyDown(key.down) || input.isKeyDown(key.s) || input.swipeDown()) {
			curPlayerDirection = BUTTON_KEY.DOWN;
		}
		else {
			curPlayerDirection = null;
		}

		function tryButtonDownActions(keyName, isButtonHeld, afterButtonPressFunc) {
			if (player() && player().btn != null) {
				cueScript(
					player().btn,
					player(),
					function(result) {
						// todo : should I also consider the return value?
						if (!player().lok && afterButtonPressFunc) {
							afterButtonPressFunc();
						}

						cueButtonDownScripts(keyName);
					},
					[keyName]);
			}
			else {
				if (player() && !player().lok && afterButtonPressFunc) {
					afterButtonPressFunc();
				}

				cueButtonDownScripts(keyName);
			}
		}

		if (curPlayerDirection != null) {
			if (curPlayerDirection != prevPlayerDirection) {
				// new direction!
				tryButtonDownActions(
					curPlayerDirection,
					false,
					function() { movePlayer(curPlayerDirection); });

				playerHoldToMoveTimer = 500;
			}
			else {
				// held
				playerHoldToMoveTimer -= deltaTime;

				if (playerHoldToMoveTimer <= 0) {
					tryButtonDownActions(
						curPlayerDirection,
						true,
						function() { movePlayer(curPlayerDirection); });

					playerHoldToMoveTimer = 150;
				}
			}
		}

		/* OKAY BUTTON INPUT */
		if (input.isKeyDown(key.enter) || input.isKeyDown(key.space) || input.isTapReleased()) {
			if (!isOkayButtonDown) {
				isOkayButtonDown = true;

				// todo : is this the keycode I want?
				// todo : should I implement held actions for this button?
				// todo : what if this sets off a dialog -- do I need to reset the okay button?
				tryButtonDownActions(BUTTON_KEY.OKAY, false);
			}
		}
		else {
			isOkayButtonDown = false;
		}
	}
}

// TODO : should any of this live inside the script module?
var scriptCues = [];
var isScriptRunning = false;
function isScriptInterpreterBusy() {
	return isScriptRunning || scriptCues.length > 0;
}

function updateCuedScripts() {
	// add animation frame tick scripts
	if (!isNarrating && !isEnding && !dialogBuffer.IsActive() && !transition.IsTransitionActive() && !isScriptInterpreterBusy()) {
		if (animationCounter === 0) {
			for (var i in spriteInstances) {
				var spr = spriteInstances[i];
				if (spr.tik != null && spr.id in tile) {
					cueScript(spr.tik, spr, function() {}, [tile[spr.drw].animation.frameIndex]);
				}
			}
		}
	}

	// run as many scripts as we can this frame
	while (!isNarrating && !isEnding && !dialogBuffer.IsActive() && !transition.IsTransitionActive() && !isScriptRunning && scriptCues.length > 0) {
		isScriptRunning = true;

		var scriptInfo = scriptCues.shift();

		dialogRenderer.Reset();
		dialogBuffer.Reset();

		var onScriptEnd = function(value) {
			if (scriptInfo.callback) {
				scriptInfo.callback(value);
			}

			// todo : will this break with callbacks that start dialog?
			isScriptRunning = false;
		};

		if (scriptInfo.onStart != undefined && scriptInfo.onStart != null) {
			scriptInfo.onStart();
		}

		dialogRenderer.SetCentered(isNarrating);

		if (dialog[scriptInfo.id].type === ScriptType.Function) {
			scriptInterpreter.RunFunction(dialog[scriptInfo.id], scriptInfo.instance, scriptInfo.parameters, onScriptEnd);
		}
		else {
			scriptInterpreter.Run(dialog[scriptInfo.id], scriptInfo.instance, onScriptEnd);
		}
	}
}

function cueScript(scriptId, instance, callback, parameters, onStart) {
	scriptCues.push({
		id: scriptId,
		instance: instance,
		callback: callback,
		parameters: parameters,
		onStart: onStart,
	});
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	// todo : should sprites have their own animation counter? or share the global one?
	if (animationCounter >= animationTime) {
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;
	}
}

var colorCycleCounter = 0;
var colorCycleTime = 80; // todo : is this the speed I want? (closest to the original speed would be ~71)
function updateColorCycle() {
	colorCycleCounter += deltaTime;

	if (colorCycleCounter >= colorCycleTime) {
		color.Cycle();
		colorCycleCounter = 0;
	}
}

function resetAllAnimations() {
	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x, y) {
	for (var id in spriteInstances) {
		if (spriteInstances[id].type === "SPR" &&
			spriteInstances[id].x === x && spriteInstances[id].y === y) {
			return spriteInstances[id];
		}
	}

	return null;
}

function getAllSpritesAt(x, y) {
	var spriteList = [];

	for (var id in spriteInstances) {
		var instance = spriteInstances[id];
		if (instance.x === x && instance.y === y) {
			spriteList.push(instance);
		}
	}

	return spriteList;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = null;
var playerHoldToMoveTimer = 0;

var isOkayButtonDown = false;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : null,
			tapReleased : false,
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = null;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = BUTTON_KEY.LEFT;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = BUTTON_KEY.RIGHT;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = BUTTON_KEY.UP;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = BUTTON_KEY.DOWN;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if (touchState.swipeDirection === null) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = null;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection === BUTTON_KEY.LEFT;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection === BUTTON_KEY.RIGHT;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection === BUTTON_KEY.UP;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection === BUTTON_KEY.DOWN;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

// todo : the way the returns work here is awkward to me
function movePlayer(direction) {
	if (player().room == null || !Object.keys(room).includes(player().room)) {
		return false; // player room is missing or invalid.. can't move them!
	}

	var result = move(player(), direction, true);
	var spr = result.collidedWith;

	var didPlayerMoveThisFrame = !result.collision;

	var ext = getExit(player().x, player().y);
	var end = getEnding(player().x, player().y);
	var itemInstanceId = getItemId(player().x, player().y);

	// do items first, because you can pick up an item AND go through a door
	if (itemInstanceId != null) {
		var itm = spriteInstances[itemInstanceId];
		var createdAtInit = itm.createdAtInit;
		var itemRoom = player().room;

		startItemDialog(itm, function() {
			// remove item from room
			delete spriteInstances[itemInstanceId];

			// mark item as removed permanently
			if (createdAtInit) {
				room[itemRoom].pickedUpItems.push("_" + itm.id + "_" + itm.originalX + "_" + itm.originalY + "_");
			}

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		startSpriteDialog(spr /*spriteInstance*/);
	}

	// map navigation:
	// todo : is the right order for this? (will it ever happen at the same time as another effect from above?)
	function moveToNeighborRoom(mapLocation, dx, dy, transition_effect) {
		var destRoom = map[mapLocation.id].map[mapLocation.y + dy][mapLocation.x + dx];
		var destX = player().x - (dx * roomsize);
		var destY = player().y - (dy * roomsize);
		var prevX = player().x - dx;
		var prevY = player().y - dy;

		if (transition_effect) {
			transition.BeginTransition(player().room, prevX, prevY, destRoom, destX, destY, transition_effect, initRoom);
			transition.UpdateTransition(0);
		}
		else {
			initRoom(destRoom);
		}

		player().room = destRoom;
		player().x = destX;
		player().y = destY;

		curRoom = destRoom;
	}

	var curMapLocation = room[curRoom].mapLocation;

	if (player().x < 0) {
		moveToNeighborRoom(curMapLocation, -1, 0, map[curMapLocation.id].transition_effect_left);
	}
	else if (player().x >= roomsize) {
		moveToNeighborRoom(curMapLocation, 1, 0, map[curMapLocation.id].transition_effect_right);
	}
	else if (player().y < 0) {
		moveToNeighborRoom(curMapLocation, 0, -1, map[curMapLocation.id].transition_effect_up);
	}
	else if (player().y >= roomsize) {
		moveToNeighborRoom(curMapLocation, 0, 1, map[curMapLocation.id].transition_effect_down);
	}

	return !result.collision;
}

function cueButtonDownScripts(keyName) {
	for (var i in spriteInstances) {
		var spr = spriteInstances[i];
		if (spr.type != TYPE_KEY.AVATAR && spr.btn != null && (spr.btn in dialog)) {
			cueScript(spr.btn, spr, function() {}, [keyName]);
		}
	}
}

function createTileCollisionInstance(tileId, x, y) {
	var definition = tile[tileId];
	var instance = new Table();

	instance.Set("ID", definition.id, { isReadOnly: true, });
	instance.Set("TYPE", definition.type, { isReadOnly: true, }); // todo : "long" names ok?
	instance.Set("NAME", definition.name, { isReadOnly: true, });
	instance.Set("DRW", definition.drw, { isReadOnly: true, });
	instance.Set("BGC", definition.bgc, { isReadOnly: true, });
	instance.Set("COL", definition.col, { isReadOnly: true, });
	instance.Set("X", x, { isReadOnly: true, });
	instance.Set("Y", y, { isReadOnly: true, });
	instance.Set("WAL", true, { isReadOnly: true, });

	return instance;
}

function createRoomWallCollisionInstance(x, y) {
	var instance = new Table();

	// todo : is WAL the right type? or ROOM? or what?
	instance.Set("TYPE", "WAL", { isReadOnly: true, }); // todo : "long" names ok?

	instance.Set("X", x, { isReadOnly: true, });
	instance.Set("Y", y, { isReadOnly: true, });
	instance.Set("WAL", true, { isReadOnly: true, });

	return instance;
}

function move(instance, direction, canEnterNeighborRoom) {
	var x = instance.x + (direction === BUTTON_KEY.LEFT ? -1 : 0) + (direction === BUTTON_KEY.RIGHT ? 1 : 0);
	var y = instance.y + (direction === BUTTON_KEY.UP ? -1 : 0) + (direction === BUTTON_KEY.DOWN ? 1 : 0);

	var collision = false;
	var collisionSprite = null;
	var knockIntoInstances = [];

	if (isRoomEdgeWall(x, y, curRoom, canEnterNeighborRoom)) {
		// todo : is it ok that the coordinates will be OUTSIDE the room? (0,-1) for example?
		knockIntoInstances.push(createRoomWallCollisionInstance(x, y));
		collision = true;
	}

	if (isWall(x, y, curRoom)) {
		var tileId = getTile(x, y);
		knockIntoInstances.push(createTileCollisionInstance(tileId, x, y));
		collision = true;
	}

	var spritesAtDestination = getAllSpritesAt(x, y);
	knockIntoInstances = knockIntoInstances.concat(spritesAtDestination);

	for (var i = 0; i < spritesAtDestination.length; i++) {
		if (spritesAtDestination[i].wal) {
			collision = true;

			// store first collideable sprite for dialog purposes
			if (collisionSprite === null && spritesAtDestination[i].type === "SPR") {
				collisionSprite = spritesAtDestination[i];
			}
		}
	}

	// cue knock into scripts
	for (var i = 0; i < knockIntoInstances.length; i++) {
		var other = knockIntoInstances[i];

		if (instance.nok && dialog[instance.nok]) {
			cueScript(instance.nok, instance, function() {}, [other, reverseButtonDirection(direction)]);
		}

		if (other.nok && dialog[other.nok]) {
			cueScript(other.nok, other, function() {}, [instance, direction]);
		}
	}

	if (!collision) {
		instance.x = x;
		instance.y = y;
	}

	return { collision: collision, collidedWith: collisionSprite, };
}

function reverseButtonDirection(direction) {
	var reverse = BUTTON_KEY.UP;

	if (direction === BUTTON_KEY.UP) {
		reverse = BUTTON_KEY.DOWN;
	}
	else if (direction === BUTTON_KEY.DOWN) {
		reverse = BUTTON_KEY.UP;
	}
	else if (direction === BUTTON_KEY.LEFT) {
		reverse = BUTTON_KEY.RIGHT;
	}
	else if (direction === BUTTON_KEY.RIGHT) {
		reverse = BUTTON_KEY.LEFT;
	}

	return reverse;
}

function updateLockState(spr) {
	if ("lockItem" in spr && spr.lockItem != null) {
		var itemCount = (spr.lockItem in player().inventory) ? player().inventory[spr.lockItem] : 0;
		spr.lok = itemCount <= 0;

		if (!spr.lok) {
			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(spr.lockItem);
			}
		}
	}
}

// todo : is this the best place to init these modules?
var transition = new TransitionManager();
var color = new Color();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect, initRoom);
			transition.UpdateTransition(0);
		}
		else {
			initRoom(ext.dest.room);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	};

	updateLockState(ext);

	if (ext.dlg != undefined && ext.dlg != null) {
		cueScript(
			ext.dlg,
			ext,
			function(result) {
				if (!ext.lok) {
					GoToDest();
				}
			});
	}
	else {
		// todo : move this check inside of GoToDest?
		if (!ext.lok) {
			GoToDest();
		}
	}
}

function initRoom(roomId) {
	// invalidate old sprites
	for (var id in spriteInstances) {
		if (id != playerInstanceId) { // skip the avatar
			spriteInstances[id].isValid = false;
			delete spriteInstances[id];
		}
	}

	instanceCount = 1;
	tilemap = createGrid(roomsize);

	function canCreateSpriteInstance(id, x, y) {
		var canCreate = true;

		if (tile[id].type === TYPE_KEY.AVATAR) {
			// avatar creation is handled elsewhere
			canCreate = false;
		}
		else if (tile[id].type === TYPE_KEY.ITEM) {
			var pickUpId = "_" + id + "_" + x + "_" + y + "_";
			if (room[roomId].pickedUpItems.indexOf(pickUpId) != -1) {
				canCreate = false;
			}
		}

		return canCreate;
	}

	// from tilemap
	for (var i = 0; i < roomsize; i++) {
		for (var j = 0; j < roomsize; j++) {
			var tileId = room[roomId].tilemap[i][j];
			if (tileId != NULL_ID && tileId in tile) {
				if (tile[tileId].type === TYPE_KEY.TILE) {
					tilemap[i][j] = tileId;
				}
				else if (canCreateSpriteInstance(tileId, j, i)) {
					instanceCount++;
					var instanceId = toB256(instanceCount);
					var instance = createSpriteInstance(instanceId, createSpriteLocation(tileId, j, i));
					instance.createdAtInit = true;
					spriteInstances[instanceId] = instance;
				}
			}
		}
	}

	// from tile overlay
	for (var i = 0; i < room[roomId].tileOverlay.length; i++) {
		var location = room[roomId].tileOverlay[i];

		if (location.id != NULL_ID && tileId in tile) {
			if (tile[location.id].type === TYPE_KEY.TILE) {
				tilemap[location.y][location.x] = location.id;
			}
			else if (canCreateSpriteInstance(location.id, location.x, location.y)) {
				instanceCount++;
				var instanceId = toB256(instanceCount);
				var instance = createSpriteInstance(instanceId, location);
				instance.createdAtInit = true;
				spriteInstances[instanceId] = instance;
			}
		}
	}

	instanceCount++;

	var palId = room[roomId].pal;
	color.StoreRoomPalette();

	// todo : is this how I want to do this?
	color.LoadRoomPalette(room[roomId].pal === NULL_ID ? null : palette[palId]);

	color.UpdateSystemPalette();
	renderer.ResetRenderCache();
}

function createSpriteLocation(id, x, y) {
	return {
		id: id,
		x: x,
		y: y,
	};
}

function createSpriteInstance(instanceId, location) {
	var definition = tile[location.id];

	var instance = new Table();

	// todo : which should be public and which private?
	// todo : are the names all the way I want?
	// todo : add read-only
	// todo : what are all the entries I want?
	instance.Set(ENTRY_KEY.SPRITE_ID, definition.id, { externalKey: "id", isReadOnly: true, });
	instance.Set(ENTRY_KEY.SPRITE_TYPE, definition.type, { externalKey: "type", isReadOnly: true, }); // todo : "long" names ok?
	instance.Set(ENTRY_KEY.SPRITE_NAME, definition.name, { externalKey: "name" }); // todo : should also be read only?
	instance.Set(ENTRY_KEY.SPRITE_TILE_ID, definition.drw, { externalKey: "drw" });
	instance.Set(ENTRY_KEY.SPRITE_BACKGROUND, definition.bgc, { externalKey: "bgc" });
	instance.Set(ENTRY_KEY.SPRITE_COLOR, definition.col, { externalKey: "col" });
	instance.Set(ENTRY_KEY.SPRITE_X, location.x, { externalKey: "x" });
	instance.Set(ENTRY_KEY.SPRITE_Y, location.y, { externalKey: "y" });
	instance.Set(ENTRY_KEY.SPRITE_LOCKED, false, { externalKey: "lok" });
	instance.Set(ENTRY_KEY.SPRITE_WALL, definition.isWall, { externalKey: "wal" });
	// other possibilities: SPD, ANM, ???

	instance.SetSecret("instanceId", instanceId);
	instance.SetSecret("isValid", true); // todo : actually use this..
	instance.SetSecret("colorOffset", definition.colorOffset);
	instance.SetSecret("dlg", definition.dlg); // todo : longer names for private entries?
	instance.SetSecret("tik", definition.tickDlgId);
	instance.SetSecret("nok", definition.knockDlgId);
	instance.SetSecret("btn", definition.buttonDownDlgId);
	instance.SetSecret("transition_effect", definition.transition_effect); // exit only
	instance.SetSecret("dest", definition.dest); // exit only // todo : rename "out"?
	instance.SetSecret("lockItem", definition.lockItem); // exit & ending only
	instance.SetSecret("createdAtInit", false);
	instance.SetSecret("originalX", location.x);
	instance.SetSecret("originalY", location.y);

	return instance;
}

function createAvatarInstance(instanceId) {
	var instance = null;

	if (playerId != null) {
		var avatarLocation = createSpriteLocation(playerId, -1, -1);
		var startingRoomId = null;
		var startingInventory = {};

		// find first room containing the player
		for (id in room) {
			for (var y = 0; y < roomsize; y++) {
				for (var x = 0; x < roomsize; x++) {
					if (startingRoomId === null && room[id].tilemap[y][x] === playerId) {
						startingRoomId = id;
						avatarLocation.x = x;
						avatarLocation.y = y;
					}
				}
			}

			for (var i = 0; i < room[id].tileOverlay.length; i++) {
				var location = room[id].tileOverlay[i];
				if (startingRoomId === null && location.id === playerId) {
					startingRoomId = id;
					avatarLocation.x = location.x;
					avatarLocation.y = location.y;
				}
			}
		}

		var instance = createSpriteInstance(instanceId, avatarLocation);

		// copy initial inventory values
		for (id in tile[playerId].inventory) {
			startingInventory[id] = tile[playerId].inventory[id];
		}

		instance.SetSecret("room", startingRoomId);
		instance.SetSecret("inventory", startingInventory);
	}

	return instance;
}

function getItemId(x, y) {
	for (var i in spriteInstances) {
		if (spriteInstances[i].type === "ITM") {
			var itm = spriteInstances[i];
			if (itm.x == x && itm.y == y) {
				return i;
			}
		}
	}

	return null;
}

function isRoomEdgeWall(x, y, roomId, canEnterNeighborRoom) {
	var blocked = false;

	if (roomId == undefined || roomId == null) {
		roomId = curRoom;
	}

	if (x < 0 || x >= roomsize || y < 0 || y >= roomsize) {
		var mapLocation = room[roomId].mapLocation;

		if (canEnterNeighborRoom && mapLocation.id != null) {
			var mapX = mapLocation.x + (x < 0 ? -1 : 0) + (x >= roomsize ? 1 : 0);
			var mapY = mapLocation.y + (y < 0 ? -1 : 0) + (y >= roomsize ? 1 : 0);

			blocked = mapX < 0 || mapX >= mapsize ||
				mapY < 0 || mapY >= mapsize || map[mapLocation.id].map[mapY][mapX] === "0";
		}
		else {
			blocked = true;
		}
	}

	return blocked;
}

function isWall(x, y, roomId) {
	if (roomId == undefined || roomId == null) {
		roomId = curRoom;
	}

	if (x < 0 || x >= roomsize || y < 0 || y >= roomsize) {
		return false;
	}

	var tileId = getTile(x, y);

	if (tileId === '0') {
		return false; // Blank spaces aren't walls, ya doofus
	}

	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf(tileId);
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId, x, y) {
	for (i in spriteInstances) {
		if (spriteInstances[i].type === "ITM") {
			var item = spriteInstances[i];
			if (x == item.x && y == item.y) {
				return item;
			}
		}
	}

	return null;
}

function getExit(x, y) {
	for (i in spriteInstances) {
		if (spriteInstances[i].type === "EXT") {
			var e = spriteInstances[i];
			if (x == e.x && y == e.y) {
				return e;
			}
		}
	}

	return null;
}

function getEnding(x, y) {
	for (i in spriteInstances) {
		if (spriteInstances[i].type === "END") {
			var e = spriteInstances[i];
			if (x == e.x && y == e.y) {
				return e;
			}
		}
	}

	return null;
}

function getTile(x, y) {
	var t = tilemap[y][x];
	return t;
}

function player() {
	return (playerInstanceId in spriteInstances) ? spriteInstances[playerInstanceId] : null;
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (id === NULL_ID || palette[id] === null || palette[id] === undefined) {
		return color.GetDefaultPalette();
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function createGrid(size, fill) {
	var grid = [];

	for (var i = 0; i < size; i++) {
		var row = [];
		for (var j = 0; j < size; j++) {
			row.push((fill != undefined && fill != null) ? fill : NULL_ID);
		}

		grid.push(row);
	}

	return grid;
}

function createMap(id) {
	return {
		id : id,
		name : null,
		map : createGrid(mapsize), // todo: name? room_map? world_map?
		transition_effect_up : null,
		transition_effect_down : null,
		transition_effect_left : null,
		transition_effect_right : null,
	};
}

function createRoom(id, palId) {
	return {
		id : id,
		name : null,
		tilemap : createGrid(roomsize),
		tileOverlay : [],
		walls : [], // todo : remove?
		pal : (palId === undefined || palId === null) ? NULL_ID : palId,
		mapLocation : { id: null, x: -1, y :-1, },
		pickedUpItems : [],
	};
}

function createPalette(id, name, colors) {
	return {
		id : id,
		name : name,
		colors : colors,
		indexOffset : COLOR_INDEX.BACKGROUND,
	};
}

function copyDrawingData(sourceDrawingData) {
	var copiedDrawingData = [];

	for (frame in sourceDrawingData) {
		copiedDrawingData.push([]);
		for (y in sourceDrawingData[frame]) {
			copiedDrawingData[frame].push([]);
			for (x in sourceDrawingData[frame][y]) {
				copiedDrawingData[frame][y].push(sourceDrawingData[frame][y][x]);
			}
		}
	}

	return copiedDrawingData;
}

function createDrawing(id, sourceDrawingData) {
	var drawingData;

	// if no image data is provided, initialize an empty initial frame
	if (!sourceDrawingData) {
		drawingData = [[]];

		for (var i = 0; i < tilesize; i++) {
			drawingData[0].push([])

			for (var j = 0; j < tilesize; j++) {
				drawingData[0][i].push(0);
			}
		}
	}
	else {
		// TODO : provide option to not copy?
		drawingData = copyDrawingData(sourceDrawingData);
	}

	renderer.SetTileSource(id, drawingData);
}

// TODO : refactor so this follows pattern of other create* methods?
function createTile(id, type, options) {
	function valueOrDefault(value, defaultValue) {
		return value != undefined && value != null ? value : defaultValue;
	}

	var isPlayer = (type === TYPE_KEY.AVATAR); // todo : back compat?

	var drwId = id;
	var inventory = isPlayer && options.inventory ? options.inventory : null;
	var isWall = (type === TYPE_KEY.TILE) && options.isWall != undefined ? options.isWall : null;
	var isUnique = isPlayer;

	var isWall = false;

	if ((type === TYPE_KEY.TILE) && options.isWall != undefined) {
		isWall = options.isWall;
	}
	else if (type === TYPE_KEY.SPRITE) {
		isWall = true;
	}

	createDrawing(drwId, options.drawingData);

	tile[id] = {
		id: id, // unique ID
		type: type, // default behavior: is it a sprite, item, or tile?
		name : valueOrDefault(options.name, null), // user-supplied name
		drw: drwId, // drawing ID
		colorOffset: COLOR_INDEX.BACKGROUND, // color offset start for global palette
		bgc: valueOrDefault(options.bgc, 0), // background color index
		col: valueOrDefault(options.col, (type === TYPE_KEY.TILE ? 1 : 2)), // color index
		animation : { // animation data // TODO: figure out how this works with instances
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId),
		},
		dlg: valueOrDefault(options.dlg, null), // dialog ID (NOTE: tiles don't use this)
		tickDlgId: valueOrDefault(options.tickDlgId, null),
		knockDlgId: valueOrDefault(options.knockDlgId, null),
		buttonDownDlgId: valueOrDefault(options.buttonDownDlgId, null),
		inventory : inventory, // starting inventory (player only)
		isWall : isWall, // does this tile block sprites from entering?
		isUnique : isUnique, // only one instance allowed? (player only)
		transition_effect : valueOrDefault(options.transition_effect, null), // exit only
		dest : {
			room : valueOrDefault(options.destRoom, null), // exit only
			x : valueOrDefault(options.destX, 0), // exit only
			y : valueOrDefault(options.destY, 0), // exit only
		},
		lockItem : valueOrDefault(options.lockItem, null), // exit & ending only
	};
}

var ScriptType = {
	Dialog : TYPE_KEY.DIALOG,
	Function : TYPE_KEY.SCRIPT,
};

function createScript(id, name, script, type) {
	if (type === undefined || type === null) {
		type = ScriptType.Dialog;
	}

	return {
		id : id,
		name : name,
		type : type,
		src : script,
	};
}

function drawRoom(room, options) {
	function getOptionOrDefault(optionId, defaultValue) {
		var doesOptionExist = (options != undefined && options != null) && (options[optionId] != undefined && options[optionId] != null);
		return doesOptionExist ? options[optionId] : defaultValue;
	}

	var frameIndex = getOptionOrDefault("frameIndex", null);
	var drawInstances = getOptionOrDefault("drawInstances", true);

	var renderOptions = { frameIndex: frameIndex, };

	var renderTarget = options && options.target ? options.target : renderer.CreateScreenTarget();

	// clear screen
	renderTarget.Clear();

	if (room === undefined && room === null) {
		// protect against invalid rooms
		return;
	}

	function isPosInRoom(x, y) {
		return x >= 0 && x < roomsize && y >= 0 && y < roomsize;
	}

	var background = tilemap;
	var foreground = createGrid(roomsize);

	if (drawInstances) {
		// make sprite grid
		var spriteIdList = sortedIdList(spriteInstances); // perf?

		for (var i = 0; i < spriteIdList.length; i++) {
			var id = spriteIdList[i];

			if (id != playerInstanceId) {
				var instance = spriteInstances[id];
				if (isPosInRoom(instance.x, instance.y)) {
					foreground[instance.y][instance.x] = id;
				}
			}
		}

		// draw avatar last
		if (playerInstanceId in spriteInstances && spriteInstances[playerInstanceId] != null) {
			var instance = spriteInstances[playerInstanceId];
			if (isPosInRoom(instance.x, instance.y)) {
				foreground[instance.y][instance.x] = playerInstanceId;
			}
		}
	}
	else {
		background = createGrid(roomsize);

		// for edit mode // todo : consolidate?
		for (var i = 0; i < room.tilemap.length; i++) {
			for (var j = 0; j < room.tilemap[i].length; j++) {
				var id = room.tilemap[i][j];

				if (id != NULL_ID && tile[id] != null) {
					if (tile[id].type === TYPE_KEY.TILE) {
						background[i][j] = id;
					}
					else {
						foreground[i][j] = id;
					}
				}
			}
		}

		for (var i = 0; i < room.tileOverlay.length; i++) {
			var location = room.tileOverlay[i];

			if (location.id != NULL_ID && tile[location.id] != null && isPosInRoom(location.x, location.y)) {
				if (tile[location.id].type === TYPE_KEY.TILE) {
					background[location.y][location.x] = location.id;
				}
				else {
					foreground[location.y][location.x] = location.id;
				}
			}
		}
	}

	// draw tiles
	for (var i = 0; i < background.length; i++) {
		for (var j = 0; j < background[i].length; j++) {
			var id = background[i][j];

			if (id != NULL_ID && tile[id] != null) {
				renderTarget.DrawTile(id, j, i, renderOptions);
			}
		}
	}

	// draw sprites
	if (drawInstances) {
		for (var i = 0; i < foreground.length; i++) {
			for (var j = 0; j < foreground[i].length; j++) {
				var id = foreground[i][j];

				if (id != NULL_ID && spriteInstances[id] != null) {
					renderTarget.DrawSprite(spriteInstances[id], j, i, renderOptions);
				}
			}
		}
	}
	else {
		for (var i = 0; i < foreground.length; i++) {
			for (var j = 0; j < foreground[i].length; j++) {
				var id = foreground[i][j];

				if (id != NULL_ID && tile[id] != null) {
					renderTarget.DrawSprite(tile[id], j, i, renderOptions);
				}
			}
		}
	}
}

function getRoomPal(roomId) {
	var defaultId = null; // todo : refactor to simplify this?

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}

	return defaultId;
}

var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function startTitle() {
	isNarrating = true;
	isEnding = false;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();

	scriptInterpreter.Run(dialog[titleId], null, function() {
		// TODO : can we refactor this part? is it needed anywhere else?
		dialogBuffer.OnDialogEnd(function() {
			isNarrating = false;
		});
	});
}

function startEndingDialog(ending) {
	// TODO : remove back compat with old endings once I'm sure I want to use this...
	var endingId = "dlg" in ending ? ending.dlg : ending.id;

	updateLockState(ending);

	cueScript(
		endingId,
		ending,
		function() {
			// todo : the nested callbacks are a bit much..
			dialogBuffer.OnDialogEnd(function() {
				isNarrating = false;

				if (ending.lok) {
					isEnding = false;
				}
			});
		},
		null,
		function() {
			isNarrating = true;
			isEnding = true;
		});
}

function startItemDialog(itemInstance, callback) {
	var tryCallback = function() {
		if (!itemInstance.lok && callback) {
			callback();
		}
	};

	var itemDlgId = itemInstance.dlg;

	if (dialog[itemDlgId]) {
		cueScript(itemDlgId, itemInstance, tryCallback);
	}
	else {
		tryCallback();
	}
}

function startSpriteDialog(spriteInstance) {
	var dialogId = spriteInstance.dlg;

	if (dialog[dialogId]) {
		cueScript(dialogId, spriteInstance, function() {});
	}
}

// TODO : re-implement
var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	// TODO
}

/* SCRIPTING */
var library = new Library();
var scriptInterpreter = new CurlicueScript();

</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>